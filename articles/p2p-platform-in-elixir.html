<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Проектирование P2P-площадки взаимного кредитования на Elixir |> Сообщество Elixir и Phoenix Framework</title>
    <meta name="description" content="Рассказываем о построении микросервисной архитектуры на Elixir для создание P2P платформы взаимного кредитования.">

    <link rel="alternate" type="application/rss+xml" title="Сообщество Elixir и Phoenix Framework" href="/feed.xml" />
    <link rel="canonical" href="https://wunsh.ru/articles/p2p-platform-in-elixir.html">

    <style type="text/css">@import url("//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700&subset=cyrillic");</style>
    <link rel="stylesheet" href="/assets/css/vendors/pure.min.css">
    <link rel="stylesheet" href="/assets/css/vendors/pure-grids-responsive.min.css">
    <link rel="stylesheet" href="/assets/css/style.css?1594516983">

    <link rel="shortcut icon" type="image/png" href="/assets/favicon.png" >
</head>


  <body>
    <div class="wunsh pure-g">
      




<div class="menu pure-u-1 pure-u-md-1-4">
  <div class="header">
    <h2 class="header__title">
      
        <a href="https://wunsh.ru" class="header__title_link" title="На главную">Эликсир и&nbsp;Вунш</a>
      
    </h2>
    <h3 class="header__tagline">Erlang + Ruby = &#10084;</h3>

    <nav class="nav">
      <ul class="nav_list">
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/elixir" class="nav_list__item_link pure-button">О языке</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/install/linux-asdf" class="nav_list__item_link pure-button">Установка</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/docs/" class="nav_list__item_link pure-button">Документация</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/guides" class="nav_list__item_link pure-button">Гайды</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/news" class="nav_list__item_link pure-button">Новости</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/articles" class="nav_list__item_link pure-button">Статьи</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/videos" class="nav_list__item_link pure-button">Видео</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/vacancies" class="nav_list__item_link pure-button">Вакансии</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/faq" class="nav_list__item_link pure-button">FAQ</a>
            </li>
          
        
      </ul>
    </nav>

    <a href="#subscribeModal" class="pure-button header__subscribe_link">Подписаться на рассылку</a>
  </div>
</div>


      <div class="content pure-u-1 pure-u-md-3-4">
        

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
    
    <h1 class="post__title" itemprop="name headline">Проектирование P2P-площадки взаимного кредитования на Elixir</h1>

    <div class="post__meta post_meta">
      <ul class="meta_list">
        <li class="meta_list__item">
          
          <span class="">
            <small class="meta_list__item_name">Дата</small>
            <time class="h-bold" datetime="2017-09-08T00:00:00+00:00" itemprop="datePublished">
              















08 сентября 2017

            </time>
          </span>
          

          
        </li>
        
        <li class="meta_list__item">
            <span class="tag_cloud tags_cloud--inline h-no_margin">
              <small class="meta_list__item_name">Теги</small> 


<ul class="tags_cloud__list">
  
    <a href="/tags/#overview" class="tags_cloud__link tag tag--overview">overview</a>
  
</ul>

            </span>
        </li>
        
        <li class="meta_list__item">
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <small class="meta_list__item_name">
              
                Перевод
              
            </small>
            <span itemprop="name" class="h-bold">Надежда Нестерова</span>
          </span>
        </li>

        <li class="meta_list__item">
          
            <div >
              <small>Оригинал</small>
              <strong>
                &laquo;<a href="https://medium.com/nebo-15/designing-a-p2p-lending-platform-with-elixir-in-mind-ffb323bf7252" style="text-transform: none; text-decoration: underline; color: #4b2e39;">Designing a P2P Lending platform with Elixir in mind</a>&raquo;
              </strong>
              <small>&copy;</small>
              <strong>Andrew Dryga</strong>
            </div>
          
        </li>
      </ul>
    </div>
  </header>

  <div class="post__content" itemprop="articleBody">
    <p>В данной статье мне бы хотелось осветить процесс разработки одного из наших последних проектов — рыночной площадки P2P, предназначенной для использования в целях секьюритизации портфелей одной очень крупной онлайн кредитной организации и портфелей многочисленных инвесторов. Я расскажу о том, <em>как безумное на первый взгляд решение о смене стека технологий оказалось отличной идеей</em>.</p>

<p>Зачем мне это? Чтобы привлечь новых разработчиков и спонсоров в сообщество Elixir. Вряд ли я смог бы назвать себя предприимчивым, но я знаю, что первое, что им пришло бы на ум, — это вопрос: «Какие проекты уже реализованы на Elixir?». Найти хорошие примеры в сети не так-то просто.</p>

<blockquote>
  <p>Предупреждение: я постараюсь держаться как можно ближе к сути проекта с технической точки зрения, но есть несколько связанных с бизнесом вопросов, которые нельзя оставить без внимания.</p>
</blockquote>

<h2 id="бизнес-задачи">Бизнес-задачи</h2>

<p>Представьте, что вы владеете кредитной организацией. А значит, изо дня в день вы даёте людям кредиты, получаете проценты, если они их погашают или теряете деньги в противном случае. При наличии хороших маркетинговых каналов и умения разбираться в людях ваш бизнес будет процветать, расти и приносить прибыль.</p>

<p>Но наступит момент, когда из-за большого количества выданных займов на новый кредит ваших финансов уже не хватит, и бизнес приостановится.</p>

<p>Может, вы начнёте искать инвесторов, которые выкупят часть вашего кредитного портфеля и, возможно, разделят ваши риски. Процент прибыли с каждого кредита снизится, но это можно будет компенсировать, развивая компанию дальше и сокращая риски.</p>

<p>Инвесторы могут быть избирательными — приобретать определённые кредиты, опираясь на результаты своего технического анализа, статистику или просто интуицию. К примеру, они захотят, чтобы портфель на 75% состоял из кредитов, выданных в Испании молодым людям от 28 до 35 лет с хорошей кредитоспособностью и высоким доходом (малый риск/низкая прибыль); и на 25% из кредитов, выданных любым людям с низкой кредитоспособностью (большой риск/высокая прибыль).</p>

<p>И где же вам с инвестором искать друг друга? На торговой площадке, где кредиторы смогут размещать информацию о кредитах, а инвесторы — свои ожидания; где данные активов дополнительно оцениваются и им подбирается лучшее предложение инвесторов; где следят за жизненным циклом каждого актива, защищая интересы обеих сторон за небольшую плату.</p>

<h2 id="общие-положения-идополнительные-требования">Общие положения и дополнительные требования</h2>

<ol>
  <li>С первого дня существования площадки нужно быть готовым к обработке сотен тысяч кредитов в день и постоянного обновлений их состояния. Это не стартап, человек с мешком денег уже готов с вами сотрудничать;</li>
  <li>Поддержка проекта должна быть передана третьему лицу после завершения стадии активной разработки, чтобы ничто не мешало продолжать создавать новые проекты;</li>
  <li>Конфигурации должны быть достаточно гибкими, чтобы предприниматели могли экспериментировать с программными продуктами без необходимости их доработки;</li>
  <li>Ограничения по ресурсам: 6 месяцев, ~10 разработчиков, несколько аналитиков и бизнесменов;</li>
  <li>Необходимо сделать интеграцию как можно проще как для кредиторов, так и для других сторон. Доработка обойдётся гораздо дороже, чем разработка;</li>
  <li>Это сфера финансовых технологий. Здесь данные не могут быть потеряны, а все операции должны быть отслеживаемыми. Для проектов такого рода даже проблемы с обработкой чисел с плавающей точкой могут стать бомбой замедленного действия. Должно быть соблюдено множество правовых норм;</li>
  <li>Планы на будущее: кредиты — не единственный актив, которым можно торговать (<em>в рамках данной статьи понятия «кредит» и «актив» эквивалентны</em>), следовательно, в дальнейшем площадка может развиваться во многих направлениях.</li>
</ol>

<h2 id="риск-перехода-кновому-стеку-технологий">Риск перехода к новому стеку технологий</h2>

<p>До проекта торговой площадки наша команда работала с PHP, MongoDB, Puppet и Angular.js, но мы взяли на себя риск, решив резко перейти к совершенно новому набору серверного ПО — Elixir, PostgreSQL, RabbitMQ, Docker, Kubernetes и React.js+Redux.js, что оказалось верным решением, как по части развития навыков членов команды, так и благодаря многочисленным преимуществам данного стека, а именно:</p>
<ol>
  <li>Намного более чистый код, который проще создавать и поддерживать;</li>
  <li>Отказоустойчивость;</li>
  <li>Конкурентное выполнение;</li>
  <li>Потоковая обработка данных;</li>
  <li>Единые бинарные файлы для всех окружений;</li>
  <li>Никакой возни с различными правилами установки серверов для различных окружений;</li>
  <li>Хорошо структурированные интерфейсные приложения и визуализация на стороне сервера;</li>
  <li>Наша команда аналитиков когда-то работала над спецификацией для BPMN нотации, которая благодаря сопоставлению с образцом и легковесным процессам отлично соотносится с кодом.</li>
</ol>

<h2 id="выспросите-как-так-получилось">Вы спросите, как так получилось?</h2>

<p>Еще летом 2016 года один мой друг обмолвился об Elixir — новом подающем надежды языке программирования. В тот момент я было подумал, что это просто ещё один бесполезный язык, но всё же решил попытать счастья и реализовать на нём новый микросервис.</p>

<p>Я изучил всю документацию на официальном сайте, посмотрел несколько роликов на YouTube и сел за код. В первые дни меня не покидало ощущение, что хорошего в Elixir мало, и всё это зря. Потом я подумал, что, может, я просто недостаточно компетентен, чтобы разглядеть все преимущества. Спустя неделю функциональное программирование сломало систему моего мышления, и я влюбился в Elixir.</p>

<p>Ecto 2.0 не взаимодействует с MongoDB, и я установил базу PostgreSQL и решил теперь работать с ней. Это решение также было навеяно <a href="https://aphyr.com/posts/322-jepsen-mongodb-stale-reads">постом Кайла Кингсбери</a> о потере данных в MongoGB и <a href="https://www.postgresql.org/docs/9.4/static/datatype-json.html">поддержке индексов JSONB в PostgreSQL</a>.</p>

<p>Процесс создания кода упростился, и я чувствовал, что никогда не был настолько продуктивным, до тех пор, пока не попытался запустить свой сервис. Оказалось, что компиляция была платформозависимой. Для решения этой проблемы мне пришлось создать образ виртуальной машины. Можно также реализовать Docker-контейнер, характеризующийся более удобной поставкой и оптимизированным жизненным циклом разработки. Кроме этого, я написал приёмочные тесты для контейнеров, чтобы убедиться, что после компиляции кода в OTP он работает во всех окружения. Этого мне как раз и не хватало в моей прошлой PHP-жизни.</p>

<p>Единые конфигурации релиза — ещё одна проблема, которую пришлось решать. Чтобы один и тот же контейнер можно было использовать во всех окружениях, он должен <a href="https://12factor.net/config">конфигурироваться во время выполнения</a>, но в Elixir реализовать такое крайне непросто. Можно установить в контейнере переменную окружения REPLACE_OS_VARS и начать использовать bash-образные переменные в конфигурациях, но что если вам вдруг понадобится целочисленное значение? На помощь придёт <a href="https://medium.com/nebo-15/runtime-configuration-migrations-and-deployment-for-elixir-applications-6295b892fa6a">Confex</a>.</p>

<p>Поскольку мне больше не хотелось возиться с настройкой сервера, контейнеры я решил запускать через Kubernetes. С его помощью развёртывание и поддержка приложений идёт как по маслу.</p>

<h2 id="общая-схема-площадки">Общая схема площадки</h2>

<p>Проанализировав все требования, торговую площадку можно разделить на несколько отдельных компонентов (предметных областей?) по их назначению:</p>
<ol>
  <li><strong>Обработчик активов</strong> (Asset Processor), где происходит обмен информацией с кредиторами, обработка полученных от них данных и создание предложений продажи;</li>
  <li><strong>Продавец</strong> (Trader), представляющий собой продающий бот, который генерирует предложения покупки в соответствии с критериями инвесторов;</li>
  <li><strong>Сопоставитель</strong> (Matcher), устанавливающий соответствие между предложениями покупки и продажи и создающий данные, необходимые для осуществления инвестиций;</li>
  <li><strong>Система управления активами</strong> или главная бухгалтерская книга (Asset Management System), обрабатывающая эти данные и осуществляющая инвестиции, перемещающая деньги между счетами, создающая отчеты и не допускающая технических овердрафтов;</li>
  <li><strong>CRM-система</strong> — центральное звено управления жизненным циклом клиента и конфигурациями.</li>
</ol>

<p><img src="https://habrastorage.org/web/6b4/252/f5a/6b4252f5a17b4369a973274de600b038.png" alt="Упрощённая модель взаимодействия" /></p>

<h2 id="asset-processor">Asset Processor</h2>

<p>Основные задачи:</p>
<ol>
  <li>Обмен информацией с кредиторами;</li>
  <li>Хранение и пополнение баз данных;</li>
  <li>Создание предложений продажи.</li>
</ol>

<p>В целях уменьшения стоимости интеграции для кредиторов, не будем вынуждать их запоминать последние отправленные на платформу данные и производить их постоянное обновление. Вместо этого они могли бы один раз в конце дня высылать массив актуальных данных, а изменения будем отслеживать мы. <strong>Это означает, что хранение данных — задача площадки.</strong></p>

<p>Поскольку эти данные не имеют сильной связи, проблема масштабирования базы данных не возникает — можно сегментировать данные в виде: клиент (кредитор), его ID и ID актива (кредита).</p>

<h2 id="обмен-информацией">Обмен информацией</h2>

<p>Прежде всего, нужно продумать, как организовать получение и обработку больших массивов данных от клиентов. Простое решение с REST JSON API не подойдёт, потому что:</p>

<ol>
  <li>Установление связи для каждого отдельного актива — дорогостоящая операция. Нам это по силам, но для кредиторов такая задача может обойтись недёшево из-за унаследованных данных в их системах. <strong>Следовательно, данные должны быть получены пачками</strong>;</li>
  <li>На стороне кредитора большинство изменений происходят не в реальном времени, а по завершении операционного дня. <strong>Пачки могут быть достаточно объёмными</strong>;</li>
  <li>Для некоторых случаев всё-таки необходимо обновление данных в течение дня, например, когда кредитор желает отозвать выплаченный займ, прежде чем его перекупит инвестор. Понятие «конец дня» для каждого клиента отлично;</li>
  <li>Документы в формате JSON возможно обработать, только загрузив весь файл в память.</li>
</ol>

<p>JSON был заменён на BSON. Это позволяет производить отложенное чтение файлов по порядку, что легко реализовать на Elixir. Существует множество библиотек для большинства других языков программирования, которые могут послужить в качестве кодировщиков JSON и обеспечить менее болезненную интеграцию.</p>

<p>Итак, мы создали единую конечную точку для пакетной выгрузки файлов в формате BSON. Кредитор отслеживает изменение данных с прежней загрузки, записывает эти данные в файл BSON и отправляет его нам.</p>

<p>Для обратной связи было решено сделать нечто похожее — создать простенький микросервис, считывающий сообщения в очереди и сохраняющий их в файл на диске. По прошествии какого-то времени этот файл высылается кредитору, очищается и процесс повторяется снова.</p>

<h2 id="хранение-иобработка-данных">Хранение и обработка данных</h2>

<p>Получив пачку файлов с данными, необходимо его обработать и сохранить его резервную копию на Amazon S3 (она может пригодиться позже для порождения событий).
Что нужно сделать:</p>
<ul>
  <li>Найти обновлённые данные для каждого актива и предписать действие: удалить предложение продажи, создать или обновить его, послать уведомление системе управления активами о выплате кредита.</li>
  <li>Сохранить изменения в базе данных;</li>
  <li>Дополнить данные — предсказать денежный поток и в соответствии с его величиной и другими данными кредитора разделить все кредиты на три группы риска.</li>
</ul>

<p>Вначале чтение файлов производилось рекурсивно, и пул соединений к базе данных стал заполняться очень быстро. Лучше всего такие проблемы решаются <a href="http://ferd.ca/queues-don-t-fix-overload.html">использованием «противодавления» во время обработки данных</a>. Здесь нам поможет <a href="https://github.com/elixir-lang/gen_stage">GenStage</a>.</p>

<p><img src="https://habrastorage.org/web/1d7/78a/01a/1d778a01a2bb4fba8495c259a81d8c06.jpeg" alt="Схема работы GenStage из презентации Жозе Валима" /></p>

<p>Благодаря ему сократилось использование памяти для большого массива данных (с нескольких Гб до почти постоянного значения 56 Мб) и прекратилась перегрузка пула соединений к БД. В итоге все части обработчика активов и некоторые другие места были переписаны с использованием нескольких GenStage.</p>

<p>Обработчик активов можно разделить на несколько частей:</p>

<ol>
  <li><strong>Интеграционный слой</strong> (ИС) — основной компонент, который получает пачки файлов и принимает решение о том, как следует их обрабатывать, а также направляет данные в соответствующие очереди. Это своего рода владелец бизнес-процесса;</li>
  <li><strong>Оценщик</strong> (Assessor) — вычисляет денежный поток и распределяет активы по группам риска;</li>
  <li><strong>Сборщик</strong> (Merger) — <a href="https://www.depesz.com/2007/07/05/how-to-insert-data-to-database-as-fast-as-possible/">эффективно</a> помещает дополненные данные обратно в базу.</li>
</ol>

<p>Вот как может выглядеть конвейер обработки данных для новых активов:</p>

<ol>
  <li><strong>ИС/Наблюдатель</strong>: запускает новый производитель GenStage, новый процесс для загрузки резервной копии файла и ожидает, пока производитель достигнет конца файла. Как только данные загружены и обработаны, удаляет файл;</li>
  <li><strong>ИС/Производитель</strong> (создаётся динамически): выполняет отложенное чтение файла (через <a href="https://github.com/nebo15/bsoneach">BSONEach</a>) и уведомляет наблюдателя, когда достигнут конец файла;</li>
  <li><strong>ИС/Производитель-Потребитель</strong>: посылает запрос к базе данных для получения последней сохранённой версии данных актива;</li>
  <li><strong>ИС/Производитель-Потребитель</strong>: вычисляет разницу между двумя состояниями и направляет данные соответствующему потребителю;</li>
  <li><strong>ИС/Потребитель</strong>: отправляет сообщение в RabbitMQ-очередь под названием <code class="highlighter-rouge">Assessor.In</code>;</li>
  <li><strong>Оценщик/Потребитель</strong>: считывает сообщения в очереди <code class="highlighter-rouge">Assessor.In</code>;</li>
  <li><strong>Оценщик/Производитель-Потребитель</strong>: посылает вызов к REST API сервиса для подсчёта денежного потока (ещё один наш проект) и дополняет данные вместе с ответом;</li>
  <li><strong>Оценщик/Производитель-Потребитель</strong>: посылает REST API ещё один такой же вызов и снова дополняет данные;</li>
  <li><strong>Оценщик/Производитель</strong>: ставит сообщение в RabbitMQ-очередь под названием <code class="highlighter-rouge">Assessor.Out</code> и подтверждает его обработку в <code class="highlighter-rouge">Assessor.In</code>;</li>
  <li><strong>ИС/Потребитель-производитель</strong>: перемещает сообщения из <code class="highlighter-rouge">Assessor.In</code> в очередь <code class="highlighter-rouge">Merger.In</code> (это для того, чтобы держать под контролем весь бизнес-процесс в ИС);</li>
  <li><strong>Сборщик</strong>: считывает сообщение в очереди <code class="highlighter-rouge">Merger.In</code>, записывает данные в базу и помещает сообщение в очередь <code class="highlighter-rouge">Merger.Out</code>;</li>
  <li><strong>ИС/Маршрутизатор</strong>: считывает сообщение из этой очереди, записывает данные в структуру предложения продажи и сворачивает их в сообщение, предназначенное для Сопоставителя.</li>
</ol>

<p>Такая схема может показаться чересчур усложнённой, но именно она будет вашим козырем в рукаве в сотрудничестве с корпоративными клиентами: они смогут заменять компоненты или использовать их повторно, а сама бизнес-логика фактически будет находиться только в одной части системы.</p>

<h2 id="порождение-событий">Порождение событий</h2>

<p>Резервные копии полученных файлов и содержимое нашей базы данных являются неизменяемыми. Вместо использования оператора обновления будем увеличивать версию существующей записи и переписывать её в новую строку.</p>

<p>Таким образом, можно гарантировать, что каждый актив каждой пачки будет обработан всего один раз. Это нужно для осуществления полноценного перезапуска пачки задач и поиска дубликатов сообщений в очереди (на практике <a href="http://bravenewgeek.com/you-cannot-have-exactly-once-delivery/">обеспечить отсутствие дубликатов очень сложно</a>).</p>

<p>Кроме того, перезапуск обработки пачек будет возможен как с удалением данных из базы, так и без него, что сэкономит множество ресурсов в продакшне.</p>

<p>Есть одна замечательная <a href="http://cidrdb.org/cidr2015/Papers/CIDR15_Paper16.pdf">статья об иммутабельных данных</a>. Мне всегда нравилось работать над проектами с неизменяемым постоянным хранилищем: это обеспечивает отслеживаемость данных на стадиях разработки и реализации, повышает уровень защиты данных и упрощает процесс сопровождения ПО.</p>

<p>Конечно, от проблемы быстрого роста размера БД никуда не деться, но можно бороться с ней посредством сохранения старых версий данных или моментальных снимков БД, удаляя оттуда всё, что не относится к бизнес-процессам.</p>

<h2 id="trader">Trader</h2>

<p>Основные задачи:</p>
<ol>
  <li>Создание REST JSON API для инвесторов (фронтенд);</li>
  <li>Сохранение критериев подбора активов в базе данных;</li>
  <li>Генерация предложений покупки в соответствии с этими критериями;</li>
  <li>Поддержка состава портфеля.</li>
</ol>

<p>Trader — одна из самых простых составляющих нашей торговой площадки. Главные особенности Trader — это API на Phoenix и микросервис «Gap Analyzer», получающий текущее состояние портфеля и генерирующий новые предложения покупки.</p>

<h2 id="gap-analyzer">Gap Analyzer</h2>

<p>Когда инвестор создаёт портфель, состоящий из активов различного рода (разобьём их на три группы по степени риска), нужно убедиться, что баланс между ними не нарушен. Иначе, учитывая текущее состояние рынка, спрос на кредиты с высокой степенью риска может значительно превышать спрос на кредиты с низкой степенью риска, в результате чего состав портфеля не будет удовлетворять ожидания клиентов, и это приведёт к потере капитала.
Чтобы уравновесить эту разницу, мы решили создавать предложения продажи (одно для каждой группы) только для небольшого количества активов портфеля (10%):</p>

<p><img src="https://habrastorage.org/web/295/4b1/16c/2954b116cca44294a246e46c01414065.png" alt="" /></p>

<p>После того как предложение было принято и равновесие активов восстановлено (например, спрос для первой группы был удовлетворён), начинается новый торговый цикл. Группы пополняются новыми активами пропорционально общей структуре:</p>

<p><img src="https://habrastorage.org/web/bbf/231/5c9/bbf2315c9c8b4a4baf043b3f6224c816.png" alt="" /></p>

<p>Цикл повторяется снова до тех пор, пока все активы не будут задействованы. Если какая-то из групп не пополняется, то следует ожидать поступления новых активов. Нарушить структуру можно лишь на несколько процентов от общего объёма.</p>

<h2 id="matcher">Matcher</h2>

<p>Основные задачи:</p>
<ol>
  <li>Сопоставление предложений продажи с предложениями покупки;</li>
  <li>Вычисление цены покупки/продажи в соответствии с условиями (инвесторы могут указать свои процентные ставки);</li>
  <li>Отправка данных к Asset Management System.</li>
</ol>

<p>Matcher считывает сообщения из очередей предложений покупки и продажи, сопоставляя их и пытаясь добиться наивысшей выгоды. Эти действия могут быть выполнены в RAM, а если какие-либо данные будут утеряны, можно ввести их заново, обратившись к Trader или Asset Processor.</p>

<p>Чаще всего инвесторы приобретают не весь кредит целиком, а малые доли в большом количестве займов, тем самым снижая свои риски.</p>

<p>Важно отметить, что для некоторых активов такая схема невыполнима, так как инвестиции для них создаются только тогда, когда инвесторы будут найдены для всех существующих предложений продажи. Поэтому, необходимо в первую очередь обработать наиболее «продаваемые» активы, иначе деньги инвесторов могут быть вложены в актив, который никто никогда не перекупит.</p>

<p>Как только приходит новое предложение продажи, оно анализируется, и к нему подбирается предложение покупки. При каждом сопоставлении рассчитывается цена покупки и продажи (разница между ними составляет наши проценты) и для каждой пары назначается цена Bid. Если достигнуто допустимое количество предложений продажи или возможна частичная продажа, отправляется сообщение с предложением продажи и информацией обо всех ценах Bid.</p>

<p>При поступлении предложения покупки имеем схожий порядок действий: выполняется поиск всех предложений продажи, удовлетворяющих заданные критерии, а допустимое количество предложений покупки уменьшается в соответствии с количеством полученных цен Bid. Если достигнуто допустимое количество предложений покупки, их поступление прекращается. В противном случае предложения покупки продолжают поступать и сопоставляться с предложениями продажи.</p>

<p>При поступлении запроса на обновление предложения, необходимо откатить все изменения до предыдущей версии и снова начать сопоставление (здесь нужно ещё подумать надо оптимизацией).</p>

<h3 id="знакомьтесь-mnesia">Знакомьтесь, Mnesia</h3>

<p>В Erlang и Elixir имеется база данных Mnesia, которая хранится в том же объёме памяти и обеспечивает поиск с низкой задержкой.</p>

<p>Поскольку время работы над данным проектом было ограничено, наша команда приняла решение вести разработку с PostgreSQL и <a href="https://github.com/nebo15/ecto_mnesia/">создать адаптер Ecto</a> в качестве упрощённой замены.</p>

<h2 id="asset-management-system">Asset Management System</h2>

<p>Основные задачи:</p>

<ol>
  <li>Подсчёт капиталовложений инвесторов;</li>
  <li>Контроль над соблюдением всех норм;</li>
  <li>Уведомление Trader о нарушении равновесия в портфеле.</li>
</ol>

<p>Вместо создания AMS с нуля мы приобрели SaaS-сервис, умеющий делать всё, что нужно, и просто написали обёртку над его API.</p>

<p>Функционирование торговой площадки заключается в запуске торговых циклов, выполнение сопоставления для каждой сделки по активу требует больших затрат, в связи с чем с помощью GenServer мы отложили на 30 секунд события, возникающие при нарушении равновесия в составе портфеля, следовательно, к Trader посылаются только совокупные данные.</p>

<p><img src="https://habrastorage.org/web/8d5/6a2/72e/8d56a272edc64b07a6da52db759fe13a.png" alt="Торговый цикл" /></p>

<h2 id="crm">CRM</h2>

<p>Эту часть мы также заимствовали: мы взяли CRM, являющуюся одной из лидеров в магическом квадранте Gartner и создали обёртку над ней.</p>

<h3 id="правовые-рамки">Правовые рамки</h3>

<p>Один из наиболее щепетильных вопросов ведения бизнеса — это вопрос о правовых рамках. Возможно, однажды вам захочется внести поправки в юридическое соглашение, но, в соответствии с правовыми нормами, это может быть сделано только с согласия инвесторов. Поэтому, при желании запустить новый проект, придётся составить новый публичный договор и запросить согласие инвесторов, прежде чем предлагать им товар.</p>

<h2 id="api-gateway">API Gateway</h2>

<p>Разрабатывая большой проект с микросервисной архитектурой, иногда приходится совершать одни и те же типичные манипуляции (управление доступом, валидация, логгирование) снова и снова. В нашем случае было решено <a href="http://github.com/nebo15/annon.api">создать API на Elixir с открытым исходным кодом</a>, который выполнял бы все эти действия, облегчая код всех остальных сервисов.</p>

<p><img src="https://habrastorage.org/web/8f0/5f7/d0c/8f05f7d0c0ef4088948c91951adab857.png" alt="Принцип работы API" /></p>

<p><a href="http://docs.annon.apiary.io/#">Документация</a> содержит всю необходимую информацию, которая поможет вам разобраться с нюансами его работы.</p>

<h2 id="возникшие-проблемы-ипути-ихрешения">Возникшие проблемы и пути их решения</h2>

<h3 id="большое-количество-микросервисов">Большое количество микросервисов</h3>
<p>Первая реализация Asset Processor состояла приблизительно из 10 микросервисов, что буквально завалило нашу немногочисленную команду работой. При каждом изменении модели данных, скриптов непрерывной интеграции и др. мы вынуждены были повторно принимать это изменение снова и снова.</p>

<p>Проще говоря, мы извлекали весь связанный с Ecto код, помещали его в отдельный репозиторий GitHub и включали его в список зависимостей в каждом модуле проекта. Но ведь бизнес-логика раскидана по нескольким модулям, значит, придётся обновлять их все, и тесты тоже, либо перестраивать все контейнеры после каждого изменения в этой зависимости.</p>

<p>Перекроив код, мы остановились на трёх микросервисах (большинство из них было заменено производителями-потребителями GenStage/Flow).</p>

<p>Это же Elixir! В большинстве случаев микросервисы вообще не понадобятся! Советуем обратить внимание на OTP-приложения. Правило, проверенное временем:</p>

<p>Если хочется развернуть что-либо отдельно, используйте для этого отдельный микросервис, в другом случае — создавайте контекст или OTP-приложение в рамках большого проекта.</p>

<p>Микросервисы — это всего лишь способ упростить код, привнеся сложность в коммуникационный уровень модели.</p>

<h3 id="защитное-программирование-иархитектура">Защитное программирование и архитектура</h3>

<p>Ещё один урок, уяснённый во время разработки Asset Processor.</p>

<p>Мне казалось, что из-за большого объёма данных, проходящих через платфотму RabbitMQ, ошибки были неизбежны. Иногда обмен heartbeat-пакетами между репликами может быть отложен из-за большого количества других данных, проходящих через протокол TCP между нодами. Это может привести к тому, что RabbitMQ будет «разрываться» между задачами, пока сеть не разгрузится. Возможна даже потеря данных.</p>

<p>Для решения этой проблемы была реализована достаточно сложная система хранения. Для каждой входящей пачки данных создавалась новая база данных (на отдельном виртуальном хосте), которая выступала в качестве временного хранилища. Каждое изменение сохранялось в эту БД, а RabbitMQ использовался только для обмена задачами (ID временной БД и ID актива) между микросервисами. По завершении анализа базу данных можно было удалить.</p>

<p>Так мы получили несколько дополнительных фич:</p>

<ul>
  <li>известен статус обработки для всей пачки (это довольно непросто, если учесть, что все процессы асинхронны, и количество полученных данных неизвестно);</li>
  <li>в непредвиденных ситуациях промежуточную базу данных всегда можно удалить и начать обработку сначала.</li>
</ul>

<p>Откровенно говоря, все эти функции оказались совершенно ни к чему, и мы вернулись к отправке сообщений через сохраняемые очереди RabbitMQ, и я не припомню, чтобы этот подход хоть чем-то мог разочаровать.</p>

<h3 id="супервизор-иего-дочерние-процессы">Супервизор и его дочерние процессы</h3>

<p>При ошибке в работе супервизора, его дочерние процессы могут быть остановлены. Вроде бы очевидная вещь, но мы умудрились натворить с этим дел.</p>

<p>После получения сообщения у нас создавался новый процесс GenServer под контролем супервизора, который должен был запускать бизнес-логику. Этот процесс кроме данных содержал в себе тег подтверждения. Когда супервизор по какой-либо причине уничтожал своего потомка, теги были безвозвратно утеряны.</p>

<p>А так как конкурентность была ограничена числом предварительных выборок (максимальное количество неподтверждённых задач, приходящееся на рабочую ноду), без тегов RabbitMQ просто не отправляла дополнительные данные, ожидая завершения предыдущих задач. Ноды получали задания, которые невозможно было обработать. Иной раз это приводило к их зависанию, и спасти ситуацию могла только перезагрузка (при разрыве связи RabbitMQ назначала получателем сообщений другую рабочую ноду).</p>

<p>Взгляните на досуге на поведение <a href="https://github.com/Nebo15/gen_task">GenTask</a>, которое как раз призвано решить эту проблему.</p>

<h2 id="помощь-сообществу">Помощь сообществу</h2>

<p>Сообщество Elixir пока немногочисленно: не стоит ожидать, что вы сможете найти в нём решение любой проблемы. Однако Elixir даёт прекрасную возможность создать это решение самому в считанные дни.</p>

<p>Если вы планируете запуск коммерческих проектов на этом языке, рассчитывайте время на разработку с запасом. И, пожалуйста, уделите немного своего времени, чтобы поделиться своими самыми полезными наработками с сообществом.</p>

<h2 id="благодарности">Благодарности</h2>

<p>Я бы хотел поблагодарить Алекса за то, что познакомил меня с Elixir, свою команду за поддержку во время работы над проектом и всех тех, кто помог мне с вычиткой статьи.</p>

<p>И особая благодарность Жозе Валиму за оперативные ответы на GitHub и за попытки помочь всеми возможными способами.</p>

  </div>

  <!-- uSocial -->
  <div class="post__share_block share_block">
    <script async src="https://usocial.pro/usocial/usocial.js?v=6.1.4" data-script="usocial" charset="utf-8"></script>
    <div class="uSocial-Share" data-pid="2fd19544e551bce292425ee8adaa31be" data-type="share" data-options="round,style2,default,absolute,horizontal,size32,counter1,counter-before,upArrow-right,nomobile" data-social="telegram,fb,vk,gPlus,twi,bookmarks"></div>
  </div>
  <!-- /uSocial -->
</article>


        <footer class="footer">
    &copy; 2020
    / Россия

    <span class="pull-right">Любые мысли и вопросы пишите на <a href="mailto:elixir@wunsh.ru">elixir@wunsh.ru</a>.</span>
</footer>

        <div id="subscribeModal" class="modal">
    <div class="modal__content">
        <a href="#close" title="Close" class="modal__close">x</a>

        <h2 class="modal__title">Ламповая рассылка про&nbsp;Эликсир</h2>

        <p>Один-два раза в&nbsp;неделю присылаем тёплые письма об&nbsp;Эликсире: переводы самых интересных статей до&nbsp;их&nbsp;появления в&nbsp;открытом доступе, анонсы событий и&nbsp;вкусные бонусы.</p>

        <form action="//wunsh.us14.list-manage.com/subscribe/post?u=c81ca3d4693f62db7f7f67c71&amp;id=a192e2dfef" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="pure-form h-tc validate" target="_blank" novalidate>
            <input type="email" value="" name="EMAIL" class="modal__input pure-input-rounded large" id="mce-EMAIL" placeholder="Твоя почта" required>
            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c81ca3d4693f62db7f7f67c71_a192e2dfef" tabindex="-1" value=""></div>

            <input type="submit" value="Присоединиться" name="subscribe" onClick="yaCounter39773490.reachGoal('SUBSCRIBED'); return true" id="mc-embedded-subscribe" class="pure-button button-success large">
        </form>

        <p>Обязательно подтверди почту, перейдя по&nbsp;ссылке в&nbsp;письме, иначе мы&nbsp;не&nbsp;сможем делиться с&nbsp;тобой полезностями.</p>

        <p>Надоедать точно не&nbsp;будем :)</p>
    </div>
</div>

        <script src="/assets/js/vendors/zepto.min.js"></script>

<script>
    if ($(".post--docs").length) {
        $(".footer").addClass("footer--docs")
    }

    $(".modal--close_backdrop").click(function(){
        window.location.hash = "";
    });
</script>

        <!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter39773490 = new Ya.Metrika({
                    id:39773490,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true,
                    ut:"noindex"
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/39773490?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

      </div>
    </div>
  </body>
</html>
