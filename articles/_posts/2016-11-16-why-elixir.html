---
title: Почему мы выбираем Elixir
excerpt: Почему мы выбираем Elixir.
author: nadezhda
source_url: https://dockyard.com/blog/2015/04/08/elixir-come-for-the-syntax-stay-for-everything-else
source_author: Brian Cardarella
public: true
tags: [overview]
---
<p>Я&nbsp;программирую уже более 20&nbsp;лет. Начал с&nbsp;Basic, потом переключился на&nbsp;C++ и&nbsp;два года потратил на&nbsp;Assembly (MASM). Затем я&nbsp;открыл для себя Ruby&nbsp;&mdash; язык, который полностью изменил мое представление о&nbsp;программировании. Я&nbsp;полюбил Ruby. Полюбил его за&nbsp;то, что представители элиты программистов стараются не&nbsp;воспринимать всерьёз. За&nbsp;синтаксис.</p>

<p>Знаете, синтаксис для меня не&nbsp;пустой звук. Можете считать меня легкомысленным старомодным глупцом, но&nbsp;я&nbsp;думаю, что это очень важно. В&nbsp;добавок, изучая Ruby, я&nbsp;нашёл себе единомышленников.</p>

<p>Когда появились языки&nbsp;Go и&nbsp;Rust, я&nbsp;был разочарован. По&nbsp;части производительности и&nbsp;многого другого они явно выигрывали, но&nbsp;вот синтаксис по&nbsp;сравнению с&nbsp;Ruby подкачал. Для чего они вообще создавались? Ruby и&nbsp;Python доказали одну очевидную вещь: людей привлекает простой и&nbsp;читабельный синтаксис. Новые языки должны развиваться, базируясь на&nbsp;лучших из&nbsp;имеющихся принципов. Go, похоже, ориентирован на&nbsp;поклонников C/C++, в&nbsp;то&nbsp;время как Rust интересен JavaScript-разработчикам. Я&nbsp;думаю, что это, скорее, дело вкуса.</p>

<p>Elixir&nbsp;же совсем другой. Я&nbsp;бы поставил в&nbsp;один ряд Elixir, Go&nbsp;и&nbsp;Rust и&nbsp;сказал&nbsp;бы, что именно эти три языка зададут направление развития backend-разработки в&nbsp;следующем десятилетии. Я&nbsp;обнаружил, что Elixir, помимо схожего с&nbsp;Ruby синтаксиса, имеет ряд других преимуществ.</p>

<p>Его синтаксис достаточно поверхностен, но&nbsp;в&nbsp;этом и&nbsp;есть его привлекательность. С этого всё и&nbsp;началось. Когда я&nbsp;впервые увидел код на&nbsp;языке Elixir, я&nbsp;подумал: &laquo;Так, ладно. Я&nbsp;вполне могу в&nbsp;нём разобраться&raquo;.</p>

<p>Думаю, большинство Ruby-разработчиков рано или поздно придут к&nbsp;Elixir. Похоже, многих из&nbsp;них привлекает&nbsp;Go, но, предполагаю, как только они увидят, какие возможности даёт Elixir, его преимущество будет для них налицо.</p>

<p>Однако для языка программирования иметь свою &laquo;изюминку&raquo;&nbsp;&mdash; слишком мало. Что-то более существенное должно побуждать людей пользоваться&nbsp;им. Для меня таким фактором стало функциональное программирование.</p>

<p>Похоже, оно снова набирает обороты: каждый день выходит новая статья о&nbsp;том, почему стоит выбрать путь функционального программирования. Рассмотрим несколько основных причин.</p>

<h2>1. Масштабируемость</h2>

<p>Черта, присущая языку Erlang. Приложения, написанные на&nbsp;языке Elixir, стремятся по&nbsp;максимуму использовать все ядра процессора, что, по&nbsp;сравнению с&nbsp;Ruby, очень большой прыжок вперёд. Нет необходимости писать для этого какой-либо код: виртуальная машина Erlang&nbsp;VM (BEAM) автоматически сделает это за&nbsp;вас, а&nbsp;это означает, что железо будет использоваться эффективно. Несколько лет назад из-за высокой стоимости многоядерных процессоров такой подход оказался&nbsp;бы бессмысленным. Теперь цена на&nbsp;них заметно снизилась, что добавляет преимуществ языку Elixir.</p>

<h2>2. Память</h2>

<p>Программы, написанные на&nbsp;языке Elixir, разделены на&nbsp;множество изолированных процессов. В&nbsp;сборщике мусора нет ничего необычного за&nbsp;исключением того, что на&nbsp;его работоспособность практически не&nbsp;оказывает влияние использование <b>нескольких</b> исполняемых участков кода вместо одного. К&nbsp;тому&nbsp;же можно провести параллель между такими кратковременными процессами и&nbsp;понятием объектов в&nbsp;языках, основанных на&nbsp;принципах ООП. В&nbsp;процесс передаются сообщения, а&nbsp;на&nbsp;выходе получается какое-то значение. Память выделяется отдельно под каждый процесс, и&nbsp;если он&nbsp;достаточно кратковременный, то&nbsp;сборщик мусора не&nbsp;включается, а&nbsp;процесс завершается сразу после его отработки. В&nbsp;языке Ruby, напротив, все как&nbsp;бы существует в&nbsp;одной вселенной, и, если объект перестаёт использоваться, сборщик мусора обязательно начнет свою работу, что в&nbsp;итоге повлияет на&nbsp;производительность.</p>

<h2>3. Иммутабельность</h2>

<p>В&nbsp;те&nbsp;времена, когда память была дорогостоящей, понятие &laquo;иммутабельность&raquo; приносило одни лишь страдания. Зачем создавать приложения, нещадно расходующие память из-за наличия в&nbsp;них переменных, которые нельзя изменить? В&nbsp;настоящее время память стала очень дешёвой, и&nbsp;эта проблема потеряла свою актуальность. Учитывая все вышесказанное, можно определить задачу иммутабельности в&nbsp;том ключе, в&nbsp;котором это понятие изначально задумывалось: поддержка состояния. Работая с&nbsp;параллельными процессами, нужно иметь в&nbsp;виду&nbsp;то, что состояние процесса становится крайне важным моментом. Если, скажем, переменная&nbsp;<span>X</span> должна иметь конкретное значение, а&nbsp;код пишется на&nbsp;языке, в&nbsp;котором та&nbsp;же <span>X</span> может изменяться, то&nbsp;проблем не&nbsp;избежать.</p>

<h2>4. Отказоустойчивость</h2>

<p>Я&nbsp;был под большим впечатлением, когда подробно изучал это свойство. Вы, наверное, слышали, что Erlang создавался для использования в&nbsp;телекоммуникационных системах? Как часто вам доводилось получать от&nbsp;вашего мобильного оператора сообщения вроде: &laquo;В&nbsp;связи с&nbsp;обновлением системы возможны кратковременные перерывы связи&raquo;? Такое время безотказной работы достижимо и&nbsp;с&nbsp;Elixir. Еще одна немаловажная особенность&nbsp;&mdash; это горячая замена кода. Развёртывание без простоя теперь <b>действительно возможно</b>.</p>

<h2>5. Сообщество</h2>

<p>Это, скорее, мой личный пункт. Меня привлекают технологии, не&nbsp;привязанные к&nbsp;каким-то конкретным компаниям. Языки Go&nbsp;и&nbsp;Rust в&nbsp;большинстве своём принадлежат только Google и&nbsp;Mozilla. Они всегда будут находиться под контролем своих создателей или корпораций-владельцев, в&nbsp;то&nbsp;время как Elixir не&nbsp;относится к&nbsp;какой-либо компании, поэтому является более доступным по&nbsp;части своего развития. Это позволяет отдельным организациям участвовать в&nbsp;совершенствовании языка путём создания сценариев использования (да, Erlang тоже попадает под это описание, но&nbsp;он&nbsp;в&nbsp;этом случае, пожалуй, стоит на&nbsp;месте).</p>

<p>Сообщество Elixir-разработчиков чем-то похоже на&nbsp;то, каким когда-то было сообщество Ruby-разработчиков. То&nbsp;же самое я&nbsp;говорил и&nbsp;про сообщество разработчиков Ember.js. Возможно, для меня Ruby&nbsp;&mdash; своеобразный наркотик и&nbsp;я&nbsp;просто пытаюсь снова словить от&nbsp;него кайф.</p>

<h2>Заключение</h2>

<p>С&nbsp;моей командой мы&nbsp;активно изучаем Elixir на&nbsp;протяжении нескольких месяцев. Чем глубже я&nbsp;погружаюсь в&nbsp;него, тем больше он&nbsp;мне нравится. Ставки на&nbsp;Elixir довольно высоки, так что, если вы&nbsp;Ruby-разработчик, желающий сдвинуться с&nbsp;места, я&nbsp;настоятельно рекомендую вам ознакомиться с&nbsp;ним. Начать лучше всего с&nbsp;книги Дэйва Томаса <i>(Вунш &ndash; которую мы, кстати говоря, <a href="/first_contest.html">разыгрываем здесь</a>)</i>.</p>
