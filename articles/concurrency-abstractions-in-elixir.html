<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Параллельное программирование на Elixir |> Сообщество Elixir и Phoenix Framework</title>
    <meta name="description" content="Для написания конкурентного кода, Elixir предоставляет разработчикам простые абстракции. В данной статье будут рассмотрены три из них – Task, Agent и GenServer.">

    <link rel="alternate" type="application/rss+xml" title="Сообщество Elixir и Phoenix Framework" href="/feed.xml" />
    <link rel="canonical" href="https://wunsh.ru/articles/concurrency-abstractions-in-elixir.html">

    <style type="text/css">@import url("//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700&subset=cyrillic");</style>
    <link rel="stylesheet" href="/assets/css/vendors/pure.min.css">
    <link rel="stylesheet" href="/assets/css/vendors/pure-grids-responsive.min.css">
    <link rel="stylesheet" href="/assets/css/style.css?1594516983">

    <link rel="shortcut icon" type="image/png" href="/assets/favicon.png" >
</head>


  <body>
    <div class="wunsh pure-g">
      




<div class="menu pure-u-1 pure-u-md-1-4">
  <div class="header">
    <h2 class="header__title">
      
        <a href="https://wunsh.ru" class="header__title_link" title="На главную">Эликсир и&nbsp;Вунш</a>
      
    </h2>
    <h3 class="header__tagline">Erlang + Ruby = &#10084;</h3>

    <nav class="nav">
      <ul class="nav_list">
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/elixir" class="nav_list__item_link pure-button">О языке</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/install/linux-asdf" class="nav_list__item_link pure-button">Установка</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/docs/" class="nav_list__item_link pure-button">Документация</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/guides" class="nav_list__item_link pure-button">Гайды</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/news" class="nav_list__item_link pure-button">Новости</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/articles" class="nav_list__item_link pure-button">Статьи</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/videos" class="nav_list__item_link pure-button">Видео</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/vacancies" class="nav_list__item_link pure-button">Вакансии</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/faq" class="nav_list__item_link pure-button">FAQ</a>
            </li>
          
        
      </ul>
    </nav>

    <a href="#subscribeModal" class="pure-button header__subscribe_link">Подписаться на рассылку</a>
  </div>
</div>


      <div class="content pure-u-1 pure-u-md-3-4">
        

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
    
    <h1 class="post__title" itemprop="name headline">Параллельное программирование на Elixir</h1>

    <div class="post__meta post_meta">
      <ul class="meta_list">
        <li class="meta_list__item">
          
          <span class="">
            <small class="meta_list__item_name">Дата</small>
            <time class="h-bold" datetime="2017-07-07T00:00:00+00:00" itemprop="datePublished">
              















07 июля 2017

            </time>
          </span>
          

          
        </li>
        
        <li class="meta_list__item">
            <span class="tag_cloud tags_cloud--inline h-no_margin">
              <small class="meta_list__item_name">Теги</small> 


<ul class="tags_cloud__list">
  
    <a href="/tags/#agent" class="tags_cloud__link tag tag--agent">agent</a>
  
    <a href="/tags/#genserver" class="tags_cloud__link tag tag--genserver">genserver</a>
  
    <a href="/tags/#overview" class="tags_cloud__link tag tag--overview">overview</a>
  
    <a href="/tags/#task" class="tags_cloud__link tag tag--task">task</a>
  
</ul>

            </span>
        </li>
        
        <li class="meta_list__item">
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <small class="meta_list__item_name">
              
                Перевод
              
            </small>
            <span itemprop="name" class="h-bold">Надежда Нестерова</span>
          </span>
        </li>

        <li class="meta_list__item">
          
            <div >
              <small>Оригинал</small>
              <strong>
                &laquo;<a href="https://blog.codeship.com/concurrency-abstractions-in-elixir/" style="text-transform: none; text-decoration: underline; color: #4b2e39;">Concurrency Abstractions in Elixir</a>&raquo;
              </strong>
              <small>&copy;</small>
              <strong>Leigh Halliday</strong>
            </div>
          
        </li>
      </ul>
    </div>
  </header>

  <div class="post__content" itemprop="articleBody">
    <p>Elixir предоставляет разработчикам простые инструменты для написания конкурентного кода. В&nbsp;одной из&nbsp;предыдущих статей была освещена <a href="https://blog.codeship.com/concurrency-in-elixir/">конкурентная модель Elixir</a> через призму основных структурных элементов конкурентности. В&nbsp;Elixir процессы подчиняются конкурентной модели акторов и&nbsp;являются фундаментом, на&nbsp;основе которого другие процессы обмениваются между собой сообщениями.</p>
<p>При реализации типовых задач вы&nbsp;наверняка уже сталкивались с&nbsp;необходимостью осуществления значительного количества стандартных действий, таких как отслеживание состояния внутри процесса или выполнение блокирующего вызова и&nbsp;ожидание ответа.</p>
<p>На&nbsp;этот счёт Elixir предоставляет ряд общепринятых абстракций, ещё более облегчающих написание конкурентного кода. В&nbsp;данной статье будут рассмотрены три таких абстракции: Task, Agent и&nbsp;GenServer.</p>
<h2>Модуль Task</h2>
<p>Модуль <code>Task</code> упрощает работу с&nbsp;конкурентными процессами еще больше. В&nbsp;нём наиболее примечательны два метода: <code>async</code>&nbsp;&mdash; начать асинхронное выполнение операций в&nbsp;другом процессе и&nbsp;<code>await</code>&nbsp;&mdash; ждать завершения операции и&nbsp;возвратить результат.</p>
<p>Для иллюстрации этого рассмотрим простейший пример, а&nbsp;затем выясним, каким образом он&nbsp;поможет ускорить работу <code>map</code> через распараллеливание.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">task</span> <span class="o">=</span> <span class="no">Task</span><span class="o">.</span><span class="n">async</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="m">5</span> <span class="o">+</span> <span class="m">5</span> <span class="k">end</span><span class="p">)</span></code></pre></figure>

<p>Команда в&nbsp;строке выше запускает анонимную функцию в&nbsp;отдельном процессе. Если на&nbsp;стадии разработки у&nbsp;вас под рукой имеется ссылка на&nbsp;задачу, вы&nbsp;сможете получить доступ к&nbsp;результату данной анонимной функции. Функция <code>async</code> возвращает не&nbsp;что иное, как ссылку на&nbsp;необходимый для получения результата PID&nbsp;процесса, в&nbsp;котором выполняется данная задача:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="p">%</span><span class="no">Task</span><span class="p">{</span><span class="ss">owner:</span> <span class="c1">#PID&lt;0.80.0&gt;, pid: #PID&lt;0.82.0&gt;, ref: #Reference&lt;0.0.7.207&gt;}</span></code></pre></figure>

<p>Давайте взглянем на&nbsp;этот <code>PID</code>, чтобы понять, что происходит с&nbsp;текущим процессом:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="no">Process</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
<span class="no">nil</span>
<span class="no">Process</span><span class="o">.</span><span class="n">alive?</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
<span class="no">false</span></code></pre></figure>

<p>Как можно заметить, такого процесса больше не&nbsp;существует; процесс завершается сразу после того, как модуль Task завершит работу. Как&nbsp;же тогда получить от&nbsp;него отклик? В&nbsp;этом нам поможет почтовый ящик вызывающего процесса:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="no">Process</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">owner</span><span class="p">)[</span><span class="ss">:messages</span><span class="p">]</span>
<span class="p">[{</span><span class="c1">#Reference&lt;0.0.7.207&gt;, 10},</span>
<span class="p">{</span><span class="ss">:DOWN</span><span class="p">,</span> <span class="c1">#Reference&lt;0.0.7.207&gt;, :process, #PID&lt;0.82.0&gt;, :normal}]</span></code></pre></figure>

<p><code>task.owner</code>&nbsp;&mdash; это и&nbsp;есть текущий процесс или <code>self()</code>. Здесь также можно видеть два входящих сообщения. Первое из&nbsp;них&nbsp;&mdash; это отклик на&nbsp;задачу <code>async</code>, а&nbsp;второе&nbsp;&mdash; уведомление от&nbsp;ссылки на&nbsp;Task-процесс о&nbsp;его завершении. Чтобы получить доступ к&nbsp;этим сообщениям, можно использовать блок receive, но&nbsp;модуль <code>Task</code> предлагает более простое решение:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="no">Task</span><span class="o">.</span><span class="n">await</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
<span class="m">10</span></code></pre></figure>

<p>Если сейчас взглянуть на&nbsp;входящие сообщения текущему процессу, то&nbsp;можно заметить, что они исчезли:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="no">Process</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">owner</span><span class="p">)[</span><span class="ss">:messages</span><span class="p">]</span>
<span class="p">[]</span></code></pre></figure>

<h3>Параллельное выполнение функции map при помощи модуля Task</h3>
<p>Рассмотрим пример работы с&nbsp;map, построенный с&nbsp;помощью функций <code>async</code> и&nbsp;<code>await</code> модуля Task. Этот&nbsp;же пример, но&nbsp;без использования <code>Task</code>, приведён в&nbsp;<a href="https://blog.codeship.com/concurrency-in-elixir/">предыдущей статье</a>. Можно видеть, что теперь он&nbsp;значительно упростился:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">Statuses</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">map</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">urls</span>
    <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="no">Task</span><span class="o">.</span><span class="n">async</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="n">process</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">)</span> <span class="k">end</span><span class="p">)))</span>
    <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="no">Task</span><span class="o">.</span><span class="n">await</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">)))</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">process</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">case</span> <span class="no">HTTPoison</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%</span><span class="no">HTTPoison</span><span class="o">.</span><span class="no">Response</span><span class="p">{</span><span class="ss">status_code:</span> <span class="n">status_code</span><span class="p">}}</span> <span class="o">-&gt;</span>
        <span class="p">{</span><span class="n">url</span><span class="p">,</span> <span class="n">status_code</span><span class="p">}</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="p">%</span><span class="no">HTTPoison</span><span class="o">.</span><span class="no">Error</span><span class="p">{</span><span class="ss">reason:</span> <span class="n">reason</span><span class="p">}}</span> <span class="o">-&gt;</span>
        <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">reason</span><span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Проведём тестирование по&nbsp;той&nbsp;же схеме, что и&nbsp;в&nbsp;прошлый раз:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">StatusesTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">parallel status map"</span> <span class="k">do</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">url1</span> <span class="o">=</span> <span class="sd">"</span><span class="s2">http://www.fakeresponse.com/api/?sleep=2"</span><span class="p">,</span>
      <span class="n">url2</span> <span class="o">=</span> <span class="sd">"</span><span class="s2">http://www.fakeresponse.com/api/?sleep=1"</span><span class="p">,</span>
      <span class="n">url3</span> <span class="o">=</span> <span class="sd">"</span><span class="s2">http://www.fakeresponse.com/api/?status=500"</span><span class="p">,</span>
      <span class="n">url4</span> <span class="o">=</span> <span class="sd">"</span><span class="s2">https://www.leighhalliday.com"</span><span class="p">,</span>
      <span class="n">url5</span> <span class="o">=</span> <span class="sd">"</span><span class="s2">https://www.reddit.com"</span>
    <span class="p">]</span>
    <span class="n">assert</span> <span class="no">Statuses</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
      <span class="p">{</span><span class="n">url1</span><span class="p">,</span> <span class="m">200</span><span class="p">},</span>
      <span class="p">{</span><span class="n">url2</span><span class="p">,</span> <span class="m">200</span><span class="p">},</span>
      <span class="p">{</span><span class="n">url3</span><span class="p">,</span> <span class="m">500</span><span class="p">},</span>
      <span class="p">{</span><span class="n">url4</span><span class="p">,</span> <span class="m">200</span><span class="p">},</span>
      <span class="p">{</span><span class="n">url5</span><span class="p">,</span> <span class="m">200</span><span class="p">}</span>
    <span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>


<p>На&nbsp;тесты ушло около 2,1&nbsp;секунды, что сигнализирует о&nbsp;работоспособности системы, поскольку это время сопоставимо с&nbsp;длительностью самого медленного HTTP-вызова в&nbsp;2&nbsp;секунды.</p>
<h2>Модуль Agent</h2>
<p>Агенты упрощают процедуру хранения состояния в&nbsp;процессе: они позволяют производить обмен состоянием/данными между различными процессами без необходимости передачи большого объёма данных каждой функции, которой может понадобиться доступ к&nbsp;ним.</p>
<p>Создадим с&nbsp;помощью Agent небольшой модуль для получения и&nbsp;установки ключей конфигураций. Функция <code>start_link</code> запускает Agent-процесс, после чего функции <code>get</code> и&nbsp;<code>set</code> получают доступ к&nbsp;конфигурационным данным и&nbsp;обновляют&nbsp;их.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">Configure</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">initial</span> <span class="p">\\</span> <span class="p">%{})</span> <span class="k">do</span>
    <span class="no">Agent</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="n">initial</span> <span class="k">end</span><span class="p">,</span> <span class="ss">name:</span> <span class="bp">__MODULE__</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Agent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="o">&amp;</span><span class="no">Map</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Agent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="o">&amp;</span><span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Вы&nbsp;наверняка заметили, что в&nbsp;примере выше обошлось без метода return и&nbsp;PID по&nbsp;той причине, что этот процесс привязан к&nbsp;имени модуля, а&nbsp;значит, такой процесс будет единственным. Проведём несколько тестов, чтобы убедиться, что всё работает как надо.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">ConfigureTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">get with initial value"</span> <span class="k">do</span>
    <span class="no">Configure</span><span class="o">.</span><span class="n">start_link</span><span class="p">(%{</span><span class="ss">env:</span> <span class="ss">:production</span><span class="p">})</span>
    <span class="n">assert</span> <span class="no">Configure</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:env</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="ss">:production</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">error when missing value"</span> <span class="k">do</span>
    <span class="no">Configure</span><span class="o">.</span><span class="n">start_link</span><span class="p">()</span>
    <span class="n">assert</span> <span class="no">Configure</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:env</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">set and then get value"</span> <span class="k">do</span>
    <span class="no">Configure</span><span class="o">.</span><span class="n">start_link</span><span class="p">()</span>
    <span class="no">Configure</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="ss">:env</span><span class="p">,</span> <span class="ss">:production</span><span class="p">)</span>
    <span class="n">assert</span> <span class="no">Configure</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:env</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="ss">:production</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Состояния агентов хранятся в&nbsp;памяти, в&nbsp;связи с&nbsp;чем следует запоминать только те&nbsp;данные, которые можно было&nbsp;бы быстро восстановить с&nbsp;помощью какой-либо стратегии перезапуска (через супервизор!). Состояния могут принадлежать к&nbsp;любому <a href="https://blog.codeship.com/understanding-elixir-types/">типу данных Elixir</a>, несмотря на&nbsp;то, что в&nbsp;предыдущем примере использовался тип <code>Map</code>.</p>

<p>В&nbsp;Elixir все процессы обрабатывают запросы последовательно. Даже при том, что Elixir является языком параллельного программирования, каждый процесс обрабатывает только один запрос в&nbsp;единицу времени. Если запрос к&nbsp;процессу выполняется медленно, доступ к&nbsp;данным в&nbsp;этом процессе будет перекрыт. На&nbsp;самом деле это даже удобно. Запросы обрабатываются последовательно в&nbsp;порядке их&nbsp;поступления, так что в&nbsp;некотором смысле это вполне предсказуемо. Нужно лишь удостовериться, что &laquo;тяжелые&raquo; задачи и&nbsp;медленно выполняющиеся вычисления осуществляются не&nbsp;в&nbsp;процессе агента, а&nbsp;в&nbsp;другом месте, например, в&nbsp;вызывающем процессе.</p>
<p>Если вам интересны более мощные и&nbsp;гибкие компоненты, то&nbsp;прочитайте про <a href="http://erlang.org/doc/man/ets.html">ETS</a>. В&nbsp;сети можно найти замечательную статью Барри Джонса <a href="https://blog.codeship.com/elixir-ets-vs-redis/">о&nbsp;сопоставлении ETS, агентов, Redis и&nbsp;других внешних инструментов</a>.</p>
<h2>Модуль GenServer</h2>
<p>Итак, мы&nbsp;рассмотрели управление выполнением параллельных вычислений с&nbsp;использованием задач и&nbsp;управление состоянием в&nbsp;процессе с&nbsp;помощью агентов. Теперь обратимся к&nbsp;модулю <a href="https://hexdocs.pm/elixir/GenServer.html">GenServer</a>, объединяющему работу с&nbsp;двумя описанными выше процедурами.</p>
<p>Воспользуемся примером <code>MyLogger</code> из&nbsp;<a href="https://blog.codeship.com/concurrency-in-elixir/">этой статьи</a> и&nbsp;перепишем его с&nbsp;использованием <code>GenServer</code>.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">MyLogger</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">GenServer</span>

  <span class="c1"># Client</span>

  <span class="k">def</span> <span class="n">start_link</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">log</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:log</span><span class="p">,</span> <span class="n">msg</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">print_stats</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:print_stats</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">return_stats</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:return_stats</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="c1"># Server</span>

  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:log</span><span class="p">,</span> <span class="n">msg</span><span class="p">},</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="n">msg</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="m">1</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:print_stats</span><span class="p">},</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="sd">"</span><span class="s2">I've logged </span><span class="si">#{</span><span class="n">count</span><span class="si">}</span><span class="s2"> messages"</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">count</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:return_stats</span><span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">count</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Во-первых, в&nbsp;самом начале модуля включаем в него <code>GenServer</code>. Это позволит в&nbsp;полной мере пользоваться функциональностью <code>GenServer</code>.</p>
<p>Следом идёт функция <code>start_link</code>. Она вызывает функцию <code>GenServer.start_link</code>, создаёт новый процесс для текущего модуля и&nbsp;передаёт начальное состояние, которое в&nbsp;данном случае равняется 0. Она возвращает кортеж <code>{:ok, pid}</code>.</p>
<p>GenServer может работать как синхронно, так и&nbsp;асинхронно. Синхронные запросы, при которых необходимо блокировать действия в&nbsp;ожидании ответа, называются <code>call</code>, асинхронные&nbsp;&mdash; <code>cast</code>.</p>
<h3>Асинхронные запросы / Cast</h3>
<p>При вызове <code>GenServer.cast(pid, {:log, msg})</code> внутри функции <code>log</code>, процессу будет отправлено сообщение с&nbsp;кортежем <code>{:log, msg}</code> в&nbsp;виде аргументов. Теперь предстоит написать функцию для обработки этого сообщения.</p>
<p>Создадим функцию <code>handle_cast</code>, в&nbsp;которой первый аргумент должен совпадать с&nbsp;полученными входящими аргументами <code>{:log, msg}</code>, а&nbsp;второй аргумент представляет собой текущее состояние процесса.</p>
<p>В&nbsp;теле функции <code>handle_cast</code> следует выполнить задачу чтения сообщения и&nbsp;отправки отклика, содержащего атом <code>:noreply</code> и&nbsp;новое состояние процесса.</p>
<h3>Синхронные запросы / Call</h3>
<p>В&nbsp;случае если от&nbsp;процесса требуется своего рода отклик, нужно использовать синхронные запросы <code>call</code>. <code>GenServer.call(pid, {:return_stats})</code> посылает процессу сообщение с&nbsp;аргументом <code>{:return_stats}</code>. По&nbsp;тому&nbsp;же принципу, что и&nbsp;для <code>cast</code>, нужно реализовать функцию <code>handle_call</code> для обработки сообщения и&nbsp;ответа на&nbsp;него.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:return_stats</span><span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">count</span><span class="p">}</span>
<span class="k">end</span></code></pre></figure>

<p>Аргументы запросов <code>call</code> несколько разнятся с&nbsp;аргументами <code>cast</code>. Они включают дополнительный аргумент <code>from</code>&nbsp;&mdash; процесс, пославший запрос. Отклик также отличен. Это кортеж, состоящий из&nbsp;трех элементов: атома <code>:reply</code>, значения, которое нужно выслать вызывающему процессы в&nbsp;качестве отклика, и&nbsp;нового состояния процесса.</p>
<p>В&nbsp;приведённом выше примере возвращаемое значение и&nbsp;новое состояние&nbsp;&mdash; одно и&nbsp;то&nbsp;же, поэтому <code>count</code> повторяется дважды.</p>
<p>Теперь модуль готов к&nbsp;практическому использованию!</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">MyLogger</span><span class="o">.</span><span class="n">start_link</span>
<span class="no">MyLogger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="sd">"</span><span class="s2">First message"</span><span class="p">)</span>
<span class="no">MyLogger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="sd">"</span><span class="s2">Another message"</span><span class="p">)</span>
<span class="no">MyLogger</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
<span class="n">stats</span> <span class="o">=</span> <span class="no">MyLogger</span><span class="o">.</span><span class="n">return_stats</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span></code></pre></figure>

<h2>Выводы</h2>
<p>В&nbsp;данной статье были рассмотрены три абстракции для параллельного программирования на&nbsp;Elixir, построенные на&nbsp;основе предоставленных языком программных возможностей. Первая из&nbsp;них&nbsp;&mdash; модуль <code>Task</code>, позволяющий исполнять код внутри отдельного процесса и&nbsp;при необходимости ожидать ответа. Вторая&nbsp;&mdash; <code>Agent</code>&nbsp;&mdash; фреймворк для управления состоянием внутри процесса. Третья&nbsp;&mdash; <code>GenServer</code>&nbsp;&mdash; фреймворк для синхронного и&nbsp;асинхронного исполнения кода и&nbsp;управления состоянием одновременно.</p>
<p>Не&nbsp;хватает только реализации возможности отслеживания процессов и&nbsp;реагирования на&nbsp;их&nbsp;завершение. Это, конечно, можно проделать вручную, но&nbsp;в&nbsp;таком случае вы&nbsp;рискуете остаться без &laquo;фантастических&raquo; способностей супервизоров и&nbsp;OTP. Фактически, они позволяют отслеживать процессы и&nbsp;предпринимать действия по&nbsp;их&nbsp;завершению, автоматически перезапуская отслеживаемые процессы и&nbsp;их&nbsp;потомков. Но&nbsp;об&nbsp;этом в&nbsp;следующий раз!</p>

  </div>

  <!-- uSocial -->
  <div class="post__share_block share_block">
    <script async src="https://usocial.pro/usocial/usocial.js?v=6.1.4" data-script="usocial" charset="utf-8"></script>
    <div class="uSocial-Share" data-pid="2fd19544e551bce292425ee8adaa31be" data-type="share" data-options="round,style2,default,absolute,horizontal,size32,counter1,counter-before,upArrow-right,nomobile" data-social="telegram,fb,vk,gPlus,twi,bookmarks"></div>
  </div>
  <!-- /uSocial -->
</article>


        <footer class="footer">
    &copy; 2020
    / Россия

    <span class="pull-right">Любые мысли и вопросы пишите на <a href="mailto:elixir@wunsh.ru">elixir@wunsh.ru</a>.</span>
</footer>

        <div id="subscribeModal" class="modal">
    <div class="modal__content">
        <a href="#close" title="Close" class="modal__close">x</a>

        <h2 class="modal__title">Ламповая рассылка про&nbsp;Эликсир</h2>

        <p>Один-два раза в&nbsp;неделю присылаем тёплые письма об&nbsp;Эликсире: переводы самых интересных статей до&nbsp;их&nbsp;появления в&nbsp;открытом доступе, анонсы событий и&nbsp;вкусные бонусы.</p>

        <form action="//wunsh.us14.list-manage.com/subscribe/post?u=c81ca3d4693f62db7f7f67c71&amp;id=a192e2dfef" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="pure-form h-tc validate" target="_blank" novalidate>
            <input type="email" value="" name="EMAIL" class="modal__input pure-input-rounded large" id="mce-EMAIL" placeholder="Твоя почта" required>
            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c81ca3d4693f62db7f7f67c71_a192e2dfef" tabindex="-1" value=""></div>

            <input type="submit" value="Присоединиться" name="subscribe" onClick="yaCounter39773490.reachGoal('SUBSCRIBED'); return true" id="mc-embedded-subscribe" class="pure-button button-success large">
        </form>

        <p>Обязательно подтверди почту, перейдя по&nbsp;ссылке в&nbsp;письме, иначе мы&nbsp;не&nbsp;сможем делиться с&nbsp;тобой полезностями.</p>

        <p>Надоедать точно не&nbsp;будем :)</p>
    </div>
</div>

        <script src="/assets/js/vendors/zepto.min.js"></script>

<script>
    if ($(".post--docs").length) {
        $(".footer").addClass("footer--docs")
    }

    $(".modal--close_backdrop").click(function(){
        window.location.hash = "";
    });
</script>

        <!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter39773490 = new Ya.Metrika({
                    id:39773490,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true,
                    ut:"noindex"
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/39773490?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

      </div>
    </div>
  </body>
</html>
