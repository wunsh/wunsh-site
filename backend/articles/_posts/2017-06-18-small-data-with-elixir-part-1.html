---
title: Малые данные в&nbsp;Elixir
excerpt: Первая статья в&nbsp;цикле статей о&nbsp;малых данных в&nbsp;Elixir. Начнём с&nbsp;определения &laquo;малые данные&raquo;, поговорим о&nbsp;том, почему они важны, вкратце рассмотрим инструмент Flow и&nbsp;пробежимся по&nbsp;содержанию следующих статей цикла.
author: nadezhda
source_url: http://blog.plataformatec.com.br/2017/03/small-data-with-elixir/
source_title: Small Data with Elixir
source_author: José Valim
tags: [genstage, flow, overview]
cover: /assets/images/dataflow.png
---
<p>Первая статья в&nbsp;цикле статей о&nbsp;малых данных в&nbsp;Elixir. Начнём с&nbsp;определения &laquo;малые данные&raquo;, поговорим о&nbsp;том, почему они важны, вкратце рассмотрим инструмент Flow и&nbsp;пробежимся по&nbsp;содержанию следующих статей цикла.</p>
<h2>Насколько малы малые данные?</h2>
<p>Малые данные&nbsp;&mdash; это данные, которые за&nbsp;требуемое количество времени может обработать одна машина. Такая обработка может проводиться пакетами, где объём данных известен заранее, либо в&nbsp;поточном режиме, где одна или несколько машин управляются с&nbsp;поступающими событиями без необходимости в&nbsp;синхронизации.</p>
<p>Группа учёных из&nbsp;Калифорнийского университета <a href="https://people.eecs.berkeley.edu/~alspaugh/papers/mapred_workloads_vldb_2012.pdf">проанализировали различные профили нагрузки MapReduce</a> и&nbsp;пришли к&nbsp;следующему выводу:</p>
<blockquote>Все профили нагрузки содержат большое количество типов заданий для планирования на&nbsp;уровне заданий и&nbsp;планирования выполнения, причём большинство из&nbsp;них работают именно с&nbsp;малыми данными. Эти задания являются &laquo;малыми&raquo; во&nbsp;всех смыслах по&nbsp;сравнению с&nbsp;остальными заданиями каждого профиля нагрузки. Они оперируют данными размером от&nbsp;десятков килобайт до&nbsp;одного гигабайта, содержат большое количество различных образцов данных и&nbsp;выполняются за&nbsp;время от&nbsp;10&nbsp;секунд до&nbsp;нескольких минут.</blockquote>
<p>Разработчики <a href="http://www.cl.cam.ac.uk/research/srg/netos/camsas/pubs/eurosys15-musketeer.pdf">Musketeer</a> во&nbsp;время работы над проектом провели сравнительный анализ нескольких программных решений и&nbsp;заключили:</p>
<blockquote>Система MapReduce с&nbsp;использованием библиотеки Metis, запущенная на&nbsp;одной машине, показывает наивысшую производительность при работе с&nbsp;малыми данными (&le; 0,5&nbsp;ГБ). Это действительно важно, ведь на&nbsp;практике более распространенными являются именно малые объёмы входных данных: 40-80% MapReduce-заданий клиентов Cloudera и&nbsp;70% заданий Facebook имеют не&nbsp;более 1&nbsp;ГБ входных данных.</blockquote>
<p>Зачастую узким местом является не&nbsp;расчёт, а&nbsp;чтение данных из&nbsp;внешних источников. Для подобных систем исключительно важна способность параллельной потоковой работы с&nbsp;внешними источниками.</p>
<p>И&nbsp;наконец, обратим внимание на&nbsp;публикацию <a href="http://www.frankmcsherry.org/assets/COST.pdf">&laquo;Масштабируемость, но&nbsp;какой ценой?&raquo;</a>. &laquo;Цена&raquo; конкретной платформы для решения конкретной задачи&nbsp;&mdash; это необходимость конфигурации платформы для превосхождения производительности <strong>однопоточной реализации</strong>.</p>
<blockquote>Вычислительная среда кластера и&nbsp;вычислительная среда одного ПК&nbsp;&mdash; разные вещи. Для первой важны высокая пропускная способность и сокращение задержек, при наличии менее производительных ядер и&nbsp;памяти. Для ПК&nbsp;же характерны более производительные ядра и&nbsp;память с&nbsp;низкой пропускной способностью. Поскольку ресурсы кластера обычно отлично подходят для реализации масштабируемых систем, в&nbsp;целях достижения максимальной производительности стоит рассматривать различные варианты железа.</blockquote>
<p>Другими словами, существует большое количество задач, решение которых гораздо более эффективно производить на&nbsp;одном компьютере, так как это поможет избежать характерные для больших данных сложность алгоритмов, сетевую передачу данных и&nbsp;сохранение состояния в&nbsp;контрольных точках.</p>
<p>Что из&nbsp;себя представляют малые данные в&nbsp;том или ином случае зависит от&nbsp;конкретной задачи, объёма данных (или частоты их&nbsp;поступления) и&nbsp;ожидаемого времени их&nbsp;обработки. В&nbsp;данном цикле статей рассматриваются решения различных задач с&nbsp;помощью <a href="https://github.com/elixir-lang/flow">библиотеки</a> <a href="https://github.com/elixir-lang/flow">Flow</a>. Flow обеспечивает конкурентность в&nbsp;одномашинных системах, а&nbsp;также подходит для работы с&nbsp;&laquo;малыми&raquo; задачами, тем самым избавляя разработчиков от&nbsp;необходимости прибегать к&nbsp;готовым программным решениям обработки больших данных.</p>
<h2>GenStage и&nbsp;Flow</h2>
<p>В&nbsp;прошлом году <a href="http://elixir-lang.org/blog/2016/07/14/announcing-genstage/">был&nbsp;представлен GenStage</a>&nbsp;&mdash; абстракция, предназначенная для обмена данными между процессами Elixir. GenStage разработан с&nbsp;учётом возможности использования данных из&nbsp;внешних систем (таких как Apache Kafka, RabbitMQ, баз данных, файлов и&nbsp;т.п.) без перегрузки системы, обрабатывающей эти данные.</p>
<p>Этапы могут как производить данные, так и&nbsp;потреблять&nbsp;их. Один этап-поставщик может иметь несколько потребителей, которые будут получать события в&nbsp;соответствии с&nbsp;выбранной стратегией. Это означает, что разработчики могут произвольно объединять этапы в&nbsp;пайплайны, обеспечивая тем самым конкурентность.</p>
<p>Однако с&nbsp;таким неконтролируемым подходом схемы работы приложений, скорее всего, будут далеки от&nbsp;оптимальных. Именно поэтому был разработан инструмент Flow, построенный на&nbsp;основе GenStage. Flow позволяет разработчикам производить обработку данных с&nbsp;помощью функциональных операций map, reduce, filter и&nbsp;т.п. Flow также предоставляет комфортные средства для секционирования данных и&nbsp;управления окнами. После задания всех необходимых параметров Flow создаёт из&nbsp;подключенных этапов сеть, через которую затем будут проходить данные. Ниже приведён простой пример использования Flow для подсчёта количества слов в&nbsp;файле:</p>
{% highlight elixir %}
File.stream!("path/to/file")
|> Flow.from_enumerable()
|> Flow.flat_map(&String.split/1)
|> Flow.partition()
|> Flow.reduce(fn -> %{} end, fn word, map ->
     Map.update(map, word, 1, & &1 + 1)
   end)
|> Enum.into(%{})
{% endhighlight %}
<p>Приведённый выше пример будет подробнее рассмотрен в&nbsp;следующих статьях.</p>
<h2>Что дальше</h2>
<p>В&nbsp;следующей статье пойдёт речь об&nbsp;отложенных вычислениях и&nbsp;асинхронных потоках данных, которые предоставляют отличную базу для использования Flow.</p>
