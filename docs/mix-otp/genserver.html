<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>GenServer |> Сообщество Elixir и Phoenix Framework</title>
    <meta name="description" content="Русскоязычное сообщество Elixir и Phoenix Framework
">

    <link rel="alternate" type="application/rss+xml" title="Сообщество Elixir и Phoenix Framework" href="/feed.xml" />
    <link rel="canonical" href="https://wunsh.ru/docs/mix-otp/genserver">

    <style type="text/css">@import url("//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700&subset=cyrillic");</style>
    <link rel="stylesheet" href="/assets/css/vendors/pure.min.css">
    <link rel="stylesheet" href="/assets/css/vendors/pure-grids-responsive.min.css">
    <link rel="stylesheet" href="/assets/css/style.css?1594516983">

    <link rel="shortcut icon" type="image/png" href="/assets/favicon.png" >
</head>


  <body>
    <div class="wunsh pure-g">
      




<div class="menu pure-u-1 pure-u-md-1-4">
  <div class="header">
    <h2 class="header__title">
      
        <a href="https://wunsh.ru" class="header__title_link" title="На главную">Эликсир и&nbsp;Вунш</a>
      
    </h2>
    <h3 class="header__tagline">Erlang + Ruby = &#10084;</h3>

    <nav class="nav">
      <ul class="nav_list">
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/elixir" class="nav_list__item_link pure-button">О языке</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/install/linux-asdf" class="nav_list__item_link pure-button">Установка</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/docs/" class="nav_list__item_link pure-button">Документация</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/guides" class="nav_list__item_link pure-button">Гайды</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/news" class="nav_list__item_link pure-button">Новости</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/articles" class="nav_list__item_link pure-button">Статьи</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/videos" class="nav_list__item_link pure-button">Видео</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/vacancies" class="nav_list__item_link pure-button">Вакансии</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/faq" class="nav_list__item_link pure-button">FAQ</a>
            </li>
          
        
      </ul>
    </nav>

    <a href="#subscribeModal" class="pure-button header__subscribe_link">Подписаться на рассылку</a>
  </div>
</div>


      <div class="content pure-u-1 pure-u-md-3-4">
        <article class="post post--docs" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="post__header">
        <h1 class="post__title" itemprop="name headline">
            <p>GenServer</p>

        </h1>
    </header>

    <div class="post__content" itemprop="articleBody">
        <p>В <a href="/docs/mix-otp/agent.html">предыдущей главе</a> мы использовали агентов для представления корзин. В первой главе мы указали имя каждой корзины, поэтому сейчас можно сделать следующее:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">CREATE</span> <span class="n">shopping</span>
<span class="no">OK</span>

<span class="no">PUT</span> <span class="n">shopping</span> <span class="n">milk</span> <span class="m">1</span>
<span class="no">OK</span>

<span class="no">GET</span> <span class="n">shopping</span> <span class="n">milk</span>
<span class="m">1</span>
<span class="no">OK</span>
</code></pre></div></div>

<p>Поскольку агенты – это процессы, каждая корзина имеет свой идентификатор процесса, но не имеет названия. Мы узнали о регистрации имени в главе <a href="/docs/processes.html">«Процессы»</a>, и вы могли бы решить эту проблему с помощью такой регистрации. Например, можно создать корзину так:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="no">Agent</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="p">%{}</span> <span class="k">end</span><span class="p">,</span> <span class="ss">name:</span> <span class="ss">:shopping</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="c1">#PID&lt;0.43.0&gt;}</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="ss">:shopping</span><span class="p">,</span> <span class="sd">"</span><span class="s2">milk"</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
<span class="ss">:ok</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:shopping</span><span class="p">,</span> <span class="sd">"</span><span class="s2">milk"</span><span class="p">)</span>
<span class="m">1</span>
</code></pre></div></div>

<p>Тем не менее, это ужасная идея! Имена процессов в Эликсире должны быть атомами. Это означает, что нужно преобразовать название корзины (часто получаемое из внешнего источника) в атомы. <strong>Ни в коем случае нельзя преобразовывать пользовательский ввод в атомы</strong>. Сборщик мусора не собирает атомы. Генерация атомов из пользовательского ввода может привести к исчерпанию системной памяти!</p>

<p>На практике, скорее всего, вы достигнете ограничения виртуальной машины Эрланга на максимальное число атомов раньше, чем исчерпаете память. Вместо того, чтобы злоупотреблять встроенной возможностью регистрации названий, давайте создадим свой собственный <em>реестр процессов</em> который будет связывать название корзины с процессом корзины.</p>

<p>Реестр должен гарантировать, что словарь всегда находится в актуальном состоянии. Например, если один из процессов падает из-за ошибки, реестр должен заметить это изменение и избежать обслуживания устаревших сущностей. Принято говорить, что реестр в Эликсире должен <em>мониторить</em> каждую корзину.</p>

<p>Мы будем использовать <a href="https://hexdocs.pm/elixir/GenServer.html">модуль <code class="highlighter-rouge">GenServer</code></a> для создания реестра процессов, который может мониторить процессы корзин. Модуль <code class="highlighter-rouge">GenServer</code> обеспечивает надежную промышленную функциональность для создания серверов на Эликсире и <code class="highlighter-rouge">OTP</code>.</p>

<h2 id="наш-первый-genserver">Наш первый <code class="highlighter-rouge">GenServer</code></h2>

<p>Модуль <code class="highlighter-rouge">GenServer</code> состоит из двух частей: клиентского API и серверных колбэков. Вы можете либо объединить обе части в один модуль, либо разделить их на клиентский и серверный модули. Клиент и сервер работают в отдельных процессах, при этом клиент передает сообщения обратно на сервер, и принимает сообщения при вызове его функций. Здесь мы объединим серверные колбэки и клиентский API в одном модуле.</p>

<p>Создайте новый файл <code class="highlighter-rouge">lib/kv/registry.ex</code> со следующим содержимым:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">GenServer</span>

  <span class="c1">## Client API</span>

  <span class="nv">@doc</span> <span class="sd">"""
  Запускает реестр.
  """</span>
  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="ss">:ok</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="nv">@doc</span> <span class="sd">"""
  Ищет идентификатор процесса корзины для `name`, сохраненного в `server`.

  Возвращает `{:ok, pid}`, если корзина существует, иначе `:error`.
  """</span>
  <span class="k">def</span> <span class="n">lookup</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">{</span><span class="ss">:lookup</span><span class="p">,</span> <span class="n">name</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="nv">@doc</span> <span class="sd">"""
  Обеспечивает наличие корзины, связанной с указанным `name` в `server`.
  """</span>
  <span class="k">def</span> <span class="n">create</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">{</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="c1">## Серверные колбэки</span>

  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{}}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:lookup</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">names</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="n">names</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">if</span> <span class="no">Map</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">names</span><span class="p">}</span>
    <span class="k">else</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">start_link</span><span class="p">([])</span>
      <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bucket</span><span class="p">)}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Первая функция <code class="highlighter-rouge">start_link/3</code> запускает <code class="highlighter-rouge">GenServer</code> и передает ему три аргумента:</p>

<ol>
  <li>
    <p>Модуль, в котором реализованы серверные колбэки, в нашем случае <code class="highlighter-rouge">__MODULE__</code> – значение текущего модуля;</p>
  </li>
  <li>
    <p>Аргументы инициализации, в нашем случае – атом <code class="highlighter-rouge">:ok</code>;</p>
  </li>
  <li>
    <p>Список опций, которые могут использоваться для определения, например, имени сервера. По умолчанию представляет пустой список. Настроим это позже.</p>
  </li>
</ol>

<p>Есть два типа запросов, которые можно отправлять в <code class="highlighter-rouge">GenServer</code>: <code class="highlighter-rouge">call</code> и <code class="highlighter-rouge">cast</code>.
 Запрос типа <code class="highlighter-rouge">call</code> – синхронный, и сервер <strong>должен</strong> ответить на него. Запрос типа <code class="highlighter-rouge">cast</code> – асинхронный, и сервер на них не отвечает.</p>

<p>Следующие две функции: <code class="highlighter-rouge">lookup/2</code> и <code class="highlighter-rouge">create/2</code>, ответственны за отправку этих запросов к серверу. В нашем случае, мы воспользовались <code class="highlighter-rouge">{:lookup, name}</code> и <code class="highlighter-rouge">{:create, name}</code> соответственно. Запросы зачастую описываются в виде таких кортежей, чтобы иметь возможность разместить несколько «аргументов» в одном слоте. Как правило, заправшиваемое действие указывается первым элементом кортежа, а оставшиеся элементы являются аргументами. Обратите внимание, что запросы должны соответствовать первым аргументам функций <code class="highlighter-rouge">handle_call/3</code> или <code class="highlighter-rouge">handle_cast/2</code>.</p>

<p>С клиентским API закончили. На стороне сервера мы можем реализовать различные колбэки, чтобы гарантировать инициализацию сервера, его отключение и обработку запросов. Эти колбэки являются необязательными, и сейчас мы реализовали только нужные нам.</p>

<p>Первый – колбэк <code class="highlighter-rouge">init/1</code>. Он принимает на вход второй аргумент из функции <code class="highlighter-rouge">GenServer.start_link/3</code> и возвращает кортеж <code class="highlighter-rouge">{:ok, state}</code>, где состояние представляет собой новый словарь. Уже можно заметить, что API модуля <code class="highlighter-rouge">GenServer</code>  делает разделение на клиентскую и серверную части более очевидным. Функция <code class="highlighter-rouge">start_link/3</code> выполняется на клиенте, а функция <code class="highlighter-rouge">init/1</code> – это соответствующий колбэк, который выполняется на сервере.</p>

<p>Для запросов типа <code class="highlighter-rouge">call/2</code> реализуется колбэк <code class="highlighter-rouge">handle_call/3</code>, который принимает <code class="highlighter-rouge">request</code>, процесс, отправивший запрос (<code class="highlighter-rouge">_from</code>) и текущее состояние сервера (<code class="highlighter-rouge">names</code>). Колбэк <code class="highlighter-rouge">handle_call/3</code> возвращает кортеж в формате <code class="highlighter-rouge">{:reply, reply, new_state}</code>. Первый элемент кортежа, <code class="highlighter-rouge">:reply</code>, показывает, что сервер должен отправлять ответ обратно клиенту. Второй элемент, <code class="highlighter-rouge">reply</code>, будет отправлен клиенту, а третий элемент, <code class="highlighter-rouge">new_state</code>, представляет собой новое состояние сервера.</p>

<p>Для запросов типа <code class="highlighter-rouge">cast/2</code> реализуется колбэк <code class="highlighter-rouge">handle_cast/2</code>, который принимает <code class="highlighter-rouge">request</code> и текущее состояние сервера (<code class="highlighter-rouge">names</code>). Колбэк <code class="highlighter-rouge">handle_cast/2</code> возвращает кортеж в формате <code class="highlighter-rouge">{:noreply, new_state}</code>. Обратите внимание, что в реальном приложении мы бы, наверное, реализовали колбэк для запроса <code class="highlighter-rouge">:create</code> с синхронным вызовом вместо асинхронного. Сейчас мы просто иллюстрируем, как реализовать асинхронный вызов.</p>

<p>Есть и другие форматы кортежей для функций <code class="highlighter-rouge">handle_call/3</code> и <code class="highlighter-rouge">handle_cast/2</code>, которые могут возвращать колбэки. Так же есть и другие колбэки, такие как <code class="highlighter-rouge">terminate/2</code> и <code class="highlighter-rouge">code_change/3</code>, которые можно было бы реализовать. Вы можете изучить <a href="https://hexdocs.pm/elixir/GenServer.html">полную документацию модуля <code class="highlighter-rouge">GenServer</code></a>, чтобы узнать о них больше.</p>

<p>Теперь давайте напишем несколько тестов, чтобы гарантировать правильную работу <code class="highlighter-rouge">GenServer</code>.</p>

<h2 id="тестирование-genserver">Тестирование <code class="highlighter-rouge">GenServer</code></h2>

<p>Тестирование <code class="highlighter-rouge">GenServer</code> не сильно отличается от тестирования агента <code class="highlighter-rouge">Agent</code>. Мы создадим сервер в колбэке <code class="highlighter-rouge">setup</code> и будем использовать его во время наших тестов. Создайте файл <code class="highlighter-rouge">test/kv/registry_test.exs</code> со следующим содержимым:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">KV</span><span class="o">.</span><span class="no">RegistryTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span><span class="p">,</span> <span class="ss">async:</span> <span class="no">true</span>

  <span class="n">setup</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">registry</span><span class="p">}</span> <span class="o">=</span> <span class="n">start_supervised</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span>
    <span class="p">%{</span><span class="ss">registry:</span> <span class="n">registry</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">spawns buckets"</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry:</span> <span class="n">registry</span><span class="p">}</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>

    <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span>
    <span class="n">assert</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span>

    <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="sd">"</span><span class="s2">milk"</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="n">assert</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="sd">"</span><span class="s2">milk"</span><span class="p">)</span> <span class="o">==</span> <span class="m">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Наш тест должен сразу же выполниться без ошибок!</p>

<p>Напомним, что благодаря функции <code class="highlighter-rouge">start_supervised</code>, модуль <code class="highlighter-rouge">ExUnit</code> следит за завершением процесса реестра после выполнения каждого теста. Если необходимость остановить <code class="highlighter-rouge">GenServer</code> – это часть логики приложения, можно использовать функцию <code class="highlighter-rouge">GenServer.stop/1</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## Клиентский API</span>

<span class="nv">@doc</span> <span class="sd">"""
Остановка реестра.
"""</span>
<span class="k">def</span> <span class="n">stop</span><span class="p">(</span><span class="n">server</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">GenServer</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">server</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="необходимость-мониторинга">Необходимость мониторинга</h2>

<p>Наш реестр почти готов. Единственный оставшийся вопрос заключается в том, что реестр может устареть, если процесс корзины остановится или упадет. Давайте добавим тест в <code class="highlighter-rouge">KV.RegistryTest</code>, который выявляет эту ошибку:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="sd">"</span><span class="s2">removes buckets on exit"</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry:</span> <span class="n">registry</span><span class="p">}</span> <span class="k">do</span>
  <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span>
  <span class="no">Agent</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
  <span class="n">assert</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Этот тест упадет, так как имя корзины остается в реестре даже после остановки процесса корзины.</p>

<p>Для исправления этой ошибки, необходимо научить реестр мониторить каждый процесс корзины, который он создает. Как только мы установим мониторинг, реестр будет получать уведомления при каждом завершении работы процесса корзины, позволяя подчистить реестр.</p>

<p>Давайте поиграем с мониторингом в консоли, выполнив команду <code class="highlighter-rouge">iex ‐S mix</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">start_link</span>
<span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="c1">#PID&lt;0.66.0&gt;}</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
<span class="c1">#Reference&lt;0.0.0.551&gt;</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Agent</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
<span class="ss">:ok</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
<span class="p">{</span><span class="ss">:DOWN</span><span class="p">,</span> <span class="c1">#Reference&lt;0.0.0.551&gt;, :process, #PID&lt;0.66.0&gt;, :normal}</span>
</code></pre></div></div>

<p>Заметьте, что функция <code class="highlighter-rouge">Process.monitor(pid)</code> возвращает уникальную ссылку, которая позволяет сопоставлять ей входящие сообщения процесса. После остановки агента, можно посмотреть все входящией сообщения при помощи функции <code class="highlighter-rouge">flush/0</code>. Обратите внимание, что пришло сообщение <code class="highlighter-rouge">:DOWN</code> с той же самой ссылкой на процесс корзины, что вернул монитор. Отметим, что процесс корзины завершен с причиной <code class="highlighter-rouge">:normal</code>.</p>

<p>Давайте переопределим серверные колбэки для исправления этого бага, и перезапустим тест. Сначала, разделим состояние <code class="highlighter-rouge">GenServer</code> на два словаря: один будет содержать соответствие <code class="highlighter-rouge">name ‐&gt; pid</code>, а другой – <code class="highlighter-rouge">ref ‐&gt; name</code>. Затем добавим мониторинг процесса корзины в функцию <code class="highlighter-rouge">handle_cast/2</code>, а также напишем колбэк <code class="highlighter-rouge">handle_info/2</code> для обработки сообщений мониторинга. Полная реализация всех серверных колбэков показана ниже:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## Серверные колбэки</span>

<span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">names</span> <span class="o">=</span> <span class="p">%{}</span>
  <span class="n">refs</span>  <span class="o">=</span> <span class="p">%{}</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">}}</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:lookup</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">_</span><span class="p">}</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">state</span><span class="p">}</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">})</span> <span class="k">do</span>
  <span class="k">if</span> <span class="no">Map</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">}}</span>
  <span class="k">else</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">start_link</span><span class="p">([])</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="no">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
    <span class="n">refs</span> <span class="o">=</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">names</span> <span class="o">=</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">}}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">handle_info</span><span class="p">({</span><span class="ss">:DOWN</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="ss">:process</span><span class="p">,</span> <span class="n">_pid</span><span class="p">,</span> <span class="n">_reason</span><span class="p">},</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">})</span> <span class="k">do</span>
  <span class="p">{</span><span class="n">name</span><span class="p">,</span> <span class="n">refs</span><span class="p">}</span> <span class="o">=</span> <span class="no">Map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
  <span class="n">names</span> <span class="o">=</span> <span class="no">Map</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">}}</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">handle_info</span><span class="p">(</span><span class="n">_msg</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">state</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Обратите внимание, что мы смогли значительно изменить реализацию сервера без изменения какого-либо клиентского API. Это одно из преимуществ явного разделения сервера и клиента.</p>

<p>Наконец, в отличие от других колбэков, мы определили условие «поймать все» для функции <code class="highlighter-rouge">handle_info/2</code>, которая отбрасывает любые неизвестные сообщения. Чтобы понять зачем это нужно, перейдем к следующему разделу.</p>

<h2 id="какой-колбэк-выбрать">Какой колбэк выбрать?</h2>

<p>До сих пор мы пользовались тремя колбэками: <code class="highlighter-rouge">handle_call/3</code>, <code class="highlighter-rouge">handle_cast/2</code> и <code class="highlighter-rouge">handle_info/2</code>. Вот что мы должны учитывать при принятии решения, когда следует использовать каждый:</p>

<ol>
  <li>
    <p>Колбэк <code class="highlighter-rouge">handle_call/3</code> должен быть использован для синхронных запросов. Он является выбором по умолчанию, поскольку ожидание ответа сервера является полезным механизмом противодавления.</p>
  </li>
  <li>
    <p>Колбэк <code class="highlighter-rouge">handle_cast/2</code> должен быть использован для асинхронных запросов, когда не нужно заботиться об ответе. Запрос типа <code class="highlighter-rouge">cast</code> не дает гарантии получения запроса сервером. По этой причине его следует использовать с осторожностью. Например, функция <code class="highlighter-rouge">create/2</code>, которую мы определили в этой главе, должна использовать функцию <code class="highlighter-rouge">call/2</code>. Мы использовали функцию <code class="highlighter-rouge">cast/2</code> для обучающих целей.</p>
  </li>
  <li>
    <p>Колбэк <code class="highlighter-rouge">handle_info/2</code> должен использоваться для всех других сообщений, которые не передаются через функции <code class="highlighter-rouge">GenServer.call/2</code> или <code class="highlighter-rouge">GenServer.cast/2</code>, включая отправку обычных сообщения функцией <code class="highlighter-rouge">send/2</code>. Мониторинг сообщений <code class="highlighter-rouge">:DOWN</code> – как раз такой пример.</p>
  </li>
</ol>

<p>Поскольку любое сообщение, в том числе отправленное через функцию <code class="highlighter-rouge">send/2</code>, попадают в колбэк <code class="highlighter-rouge">handle_info/2</code>, есть шанс, что на сервер будут приходить непредвиденные сообщения. Поэтому, если мы не определим условие «поймать все», нужного перехватчика не будет найдено, и эти сообщения могут уронить реестр. Нам не нужно беспокоиться о таких случаях для функций <code class="highlighter-rouge">handle_call/3</code> и <code class="highlighter-rouge">handle_cast/2</code>. Запросы типов <code class="highlighter-rouge">call</code> и <code class="highlighter-rouge">cast</code> выполняются только через API <code class="highlighter-rouge">GenServer</code>, так что неизвестные сообщения, скорее всего, ошибка разработчика.</p>

<p>Чтобы помочь разработчикам запомнить различия между запросами типов <code class="highlighter-rouge">call</code>, <code class="highlighter-rouge">case</code> и <code class="highlighter-rouge">info</code>, поддерживаемые возвращаемые значения и т. д., <a href="http://benjamintan.io">Бенджамин Тан Вэй Хао</a> подготовил отличную <a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf">шпаргалку для модуля <code class="highlighter-rouge">GenServer</code></a>.</p>

<h2 id="мониторы-или-ссылки">Мониторы или ссылки?</h2>

<p>Мы узнали о ссылках в <a href="/docs/processes.html">главе «Процессы»</a>. Теперь, с завершением работы над реестром, вам может быть интересно: когда следует использовать мониторы, а когда ссылки?</p>

<p>Ссылки двунаправлены. Если вы связываете два процесса, и один из них выйдет из строя, другая сторона тоже выйдет из строя (если только не перехватываются сигналы выхода). Монитор является однонаправленным: процесс мониторинга будет только получать уведомления о контролируемом. Другими словами: используйте ссылки, когда вы хотите получить связанные падения, и мониторы, когда нужно лишь получать информацию о падениях, выходах и т. п.</p>

<p>Возвращаясь к нашей реализации колбэка <code class="highlighter-rouge">handle_cast/2</code>, вы можете видеть, что реестр является как связующим, так и мониторящим процессы корзин:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">start_link</span>
<span class="n">ref</span> <span class="o">=</span> <span class="no">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
</code></pre></div></div>

<p>Это плохая идея, т. к. реестр не должен падать при падении корзины! Обычно, мы избегаем прямого создания новых процессов, вместо этого делегируя эту ответственность супервизорам. Как мы увидим в следующей главе, супервизоры полагаются на ссылки. Это объясняет, почему API на основе ссылок (например, функции <code class="highlighter-rouge">spawn_link</code>, <code class="highlighter-rouge">start_link</code> т. д.) настолько распространены в Эликсире и <code class="highlighter-rouge">OTP</code>.</p>

    </div>
</article>

<nav class="docs_nav pure-g">
    <div class="docs_nav__inner pure-u-1 pure-u-md-3-4">
        <div class="pure-g">
            <div class="docs_nav__column docs_nav__column--prev pure-u-1-3">
                
                    <a href="/docs/mix-otp/agent.html" class="docs_nav__link pure-button">
                        &larr;<span class="h-hidden_mobile"> Назад</span></a>
                
            </div>

            <div class="docs_nav__column docs_nav__column--contents pure-u-1-3">
                <a href="#docsContents" class="docs_nav__link docs_nav__link--contents pure-button">☰</a>
            </div>

            <div class="docs_nav__column docs_nav__column--next pure-u-1-3">
                
                    <a href="/docs/mix-otp/supervisor-and-application.html" class="docs_nav__link pure-button">
                        <span class="h-hidden_mobile">Вперёд </span>&rarr;
                    </a>
                
            </div>
        </div>
    </div>
</nav>

<div id="docsContents" class="modal modal--docs_contents modal--close_backdrop">
    <div class="modal__content">
        <a href="#close" title="Закрыть" class="modal__close">x</a>

        <h2 class="modal__title">Содержание</h2>

        
        <h3 id="руководство-для-начинающих">Руководство для начинающих</h3>
<ul>
  <li><a href="/docs">Введение</a></li>
  <li><a href="/docs/basic-types.html">Базовые типы</a></li>
  <li><a href="/docs/basic-operators.html">Базовые операторы</a></li>
  <li><a href="/docs/pattern-matching.html">Сопоставление с образцом</a></li>
  <li><a href="/docs/case-cond-and-if.html">Конструкции ветвления</a></li>
  <li><a href="/docs/binaries-strings-and-char-lists.html">Двоичные данные, строки и списки символов</a></li>
  <li><a href="/docs/keywords-and-maps.html">Ключевые списки и словари</a></li>
  <li><a href="/docs/modules-and-functions.html">Модули и функции</a></li>
  <li><a href="/docs/recursion.html">Рекурсия</a></li>
  <li><a href="/docs/enumerables-and-streams.html">Перечисления и потоки</a></li>
  <li><a href="/docs/processes.html">Процессы</a></li>
  <li><a href="/docs/io-and-the-file-system.html">Ввод/вывод и файловая система</a></li>
  <li><a href="/docs/alias-require-and-import.html">Директивы <code class="highlighter-rouge">alias</code>, <code class="highlighter-rouge">require</code> и <code class="highlighter-rouge">import</code></a></li>
  <li><a href="/docs/module-attributes.html">Атрибуты модулей</a></li>
  <li><a href="/docs/structs.html">Структуры</a></li>
  <li><a href="/docs/protocols.html">Протоколы</a></li>
  <li><a href="/docs/comprehensions.html">Списковые выражения</a></li>
  <li><a href="/docs/sigils.html">Сигилы</a></li>
  <li><a href="/docs/try-catch-and-rescue.html">Конструкция <code class="highlighter-rouge">try</code>, <code class="highlighter-rouge">catch</code> и <code class="highlighter-rouge">rescue</code></a></li>
  <li><a href="/docs/typespecs-and-behaviours.html">Спецификации типов и поведения</a></li>
  <li><a href="/docs/erlang-libraries.html">Библиотеки Эрланга</a></li>
  <li><a href="/docs/where-to-go-next.html">Куда двигаться дальше</a></li>
</ul>

<h3 id="микс-и-otp">Микс и <code class="highlighter-rouge">OTP</code></h3>
<ul>
  <li><a href="/docs/mix-otp/introduction-to-mix.html">Введение в Микс</a></li>
  <li><a href="/docs/mix-otp/agent.html">Агент</a></li>
  <li><a href="/docs/mix-otp/genserver.html">GenServer</a></li>
  <li><a href="/docs/mix-otp/supervisor-and-application.html">Супервизор и приложение</a></li>
  <li><a href="/docs/mix-otp/dynamic-supervisor.html">Динамический супервизор</a></li>
  <li><a href="/docs/mix-otp/ets.html">ETS</a></li>
  <li><a href="/docs/mix-otp/dependencies-and-umbrella-apps.html">Зависимости и зонтичные проекты</a></li>
  <li><a href="/docs/mix-otp/task-and-gen-tcp.html">Модули <code class="highlighter-rouge">Task</code> и <code class="highlighter-rouge">:gen_tcp</code></a></li>
  <li><a href="/docs/mix-otp/docs-tests-and-with.html">Доктесты, паттерны и оператор <code class="highlighter-rouge">with</code></a></li>
  <li><a href="/docs/mix-otp/distributed-tasks-and-configuration.html">Распределенные задачи и конфигурация</a></li>
</ul>

<h3 id="метапрограммирование">Метапрограммирование</h3>
<ul>
  <li><a href="/docs/meta/quote-and-unquote.html">Конструкции <code class="highlighter-rouge">quote</code> и <code class="highlighter-rouge">unquote</code></a></li>
  <li><a href="/docs/meta/macros.html">Макросы</a></li>
  <li><a href="/docs/meta/domain-specific-languages.html">Предметно-ориентированные языки</a></li>
</ul>

    </div>
</div>



        <footer class="footer">
    &copy; 2020
    / Россия

    <span class="pull-right">Любые мысли и вопросы пишите на <a href="mailto:elixir@wunsh.ru">elixir@wunsh.ru</a>.</span>
</footer>

        <div id="subscribeModal" class="modal">
    <div class="modal__content">
        <a href="#close" title="Close" class="modal__close">x</a>

        <h2 class="modal__title">Ламповая рассылка про&nbsp;Эликсир</h2>

        <p>Один-два раза в&nbsp;неделю присылаем тёплые письма об&nbsp;Эликсире: переводы самых интересных статей до&nbsp;их&nbsp;появления в&nbsp;открытом доступе, анонсы событий и&nbsp;вкусные бонусы.</p>

        <form action="//wunsh.us14.list-manage.com/subscribe/post?u=c81ca3d4693f62db7f7f67c71&amp;id=a192e2dfef" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="pure-form h-tc validate" target="_blank" novalidate>
            <input type="email" value="" name="EMAIL" class="modal__input pure-input-rounded large" id="mce-EMAIL" placeholder="Твоя почта" required>
            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c81ca3d4693f62db7f7f67c71_a192e2dfef" tabindex="-1" value=""></div>

            <input type="submit" value="Присоединиться" name="subscribe" onClick="yaCounter39773490.reachGoal('SUBSCRIBED'); return true" id="mc-embedded-subscribe" class="pure-button button-success large">
        </form>

        <p>Обязательно подтверди почту, перейдя по&nbsp;ссылке в&nbsp;письме, иначе мы&nbsp;не&nbsp;сможем делиться с&nbsp;тобой полезностями.</p>

        <p>Надоедать точно не&nbsp;будем :)</p>
    </div>
</div>

        <script src="/assets/js/vendors/zepto.min.js"></script>

<script>
    if ($(".post--docs").length) {
        $(".footer").addClass("footer--docs")
    }

    $(".modal--close_backdrop").click(function(){
        window.location.hash = "";
    });
</script>

        <!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter39773490 = new Ya.Metrika({
                    id:39773490,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true,
                    ut:"noindex"
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/39773490?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

      </div>
    </div>
  </body>
</html>
