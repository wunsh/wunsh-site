<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Динамический супервизор |> Сообщество Elixir и Phoenix Framework</title>
    <meta name="description" content="Русскоязычное сообщество Elixir и Phoenix Framework
">

    <link rel="alternate" type="application/rss+xml" title="Сообщество Elixir и Phoenix Framework" href="/feed.xml" />
    <link rel="canonical" href="https://wunsh.ru/docs/mix-otp/dynamic-supervisor">

    <style type="text/css">@import url("//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700&subset=cyrillic");</style>
    <link rel="stylesheet" href="/assets/css/vendors/pure.min.css">
    <link rel="stylesheet" href="/assets/css/vendors/pure-grids-responsive.min.css">
    <link rel="stylesheet" href="/assets/css/style.css?1594516983">

    <link rel="shortcut icon" type="image/png" href="/assets/favicon.png" >
</head>


  <body>
    <div class="wunsh pure-g">
      




<div class="menu pure-u-1 pure-u-md-1-4">
  <div class="header">
    <h2 class="header__title">
      
        <a href="https://wunsh.ru" class="header__title_link" title="На главную">Эликсир и&nbsp;Вунш</a>
      
    </h2>
    <h3 class="header__tagline">Erlang + Ruby = &#10084;</h3>

    <nav class="nav">
      <ul class="nav_list">
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/elixir" class="nav_list__item_link pure-button">О языке</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/install/linux-asdf" class="nav_list__item_link pure-button">Установка</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/docs/" class="nav_list__item_link pure-button">Документация</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/guides" class="nav_list__item_link pure-button">Гайды</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/news" class="nav_list__item_link pure-button">Новости</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/articles" class="nav_list__item_link pure-button">Статьи</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/videos" class="nav_list__item_link pure-button">Видео</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/vacancies" class="nav_list__item_link pure-button">Вакансии</a>
            </li>
          
        
          

          
            <li class="nav_list__item ">
              <a href="https://wunsh.ru/faq" class="nav_list__item_link pure-button">FAQ</a>
            </li>
          
        
      </ul>
    </nav>

    <a href="#subscribeModal" class="pure-button header__subscribe_link">Подписаться на рассылку</a>
  </div>
</div>


      <div class="content pure-u-1 pure-u-md-3-4">
        <article class="post post--docs" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="post__header">
        <h1 class="post__title" itemprop="name headline">
            <p>Динамический супервизор</p>

        </h1>
    </header>

    <div class="post__content" itemprop="articleBody">
        <p>Мы успешно определили супервизор, который автоматически запускается (и останавливается) как часть жизненного цикла нашего приложения.</p>

<p>Вспомните, однако, что модуль <code class="highlighter-rouge">KV.Registry</code> одновременно и связывает (через функцию <code class="highlighter-rouge">start_link</code>) и мониторит (через функцию <code class="highlighter-rouge">monitor</code>) процессы корзин в колбэке <code class="highlighter-rouge">handle_cast/2</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="o">.</span><span class="n">start_link</span><span class="p">([])</span>
<span class="n">ref</span> <span class="o">=</span> <span class="no">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
</code></pre></div></div>

<p>Ссылки двунаправлены, а значит падение корзины приведёт к падению всего реестра. Хотя у нас есть супервизор, который гарантирует, что реестр восстановит свою работу, падение реестра всё ещё приведёт к потере всех данных о связи имён корзин с их процессами.</p>

<p>Другими словами, мы хотим, чтобы реестр продолжал работать, даже если корзина падает. Давайте напишем новый тест для реестра:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="sd">"</span><span class="s2">removes bucket on crash"</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry:</span> <span class="n">registry</span><span class="p">}</span> <span class="k">do</span>
  <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span>

  <span class="c1"># Останавливаем корзину по не нормальной причине</span>
  <span class="no">Agent</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="ss">:shutdown</span><span class="p">)</span>
  <span class="n">assert</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="sd">"</span><span class="s2">shopping"</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Тест похож на «удаление корзин при выходе», кроме того, что мы передаём немного более жесткий вариант для выхода: <code class="highlighter-rouge">:shutdown</code> вместо <code class="highlighter-rouge">:normal</code>. Если процесс прекращает жизнь с причиной, отличной от <code class="highlighter-rouge">:normal</code>, все связанные процессы получают сигнал <code class="highlighter-rouge">EXIT</code>, что приводит к прекращению их всех, кроме случая, если они избегают выхода.</p>

<p>С завершением работы корзины, реестр тоже отключается, и тест падает при попытке вызвать функцию <code class="highlighter-rouge">GenServer.call/3</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1) test removes bucket on crash (KV.RegistryTest)
     test/kv/registry_test.exs:26
     ** (exit) exited in: GenServer.call(#PID&lt;0.148.0&gt;, {:lookup, "shopping"}, 5000)
         ** (EXIT) no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started
     code: assert KV.Registry.lookup(registry, "shopping") == :error
     stacktrace:
       (elixir) lib/gen_server.ex:770: GenServer.call/3
       test/kv/registry_test.exs:33: (test)
</code></pre></div></div>

<p>Мы решим эту проблему, определив новый супервизор, который будет порождать все корзины и отслеживать их состояние. Есть стратегия супервизора, которая называется <code class="highlighter-rouge">:simple_one_for_one</code>, и она прекрасно подходит для таких ситуаций: она позволяет нам задать шаблон воркера и отслеживать множество потомков, основанных на этом шаблоне. С этой стратегией ни один воркер не запускается во время инициализации супервизора. Вместо этого, они запускаются вручную с помощью  функции <code class="highlighter-rouge">Supervisor.start_child/2</code>.</p>

<h2 id="супервизор-корзин">Супервизор корзин</h2>

<p>Давайте определим модуль <code class="highlighter-rouge">KV.BucketSupervisor</code> в файле <code class="highlighter-rouge">lib/kv/bucket_supervisor.ex</code> как показано ниже:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">KV</span><span class="o">.</span><span class="no">BucketSupervisor</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Supervisor</span>

  <span class="c1"># Простой атрибут модуля, который хранит название супервизора</span>
  <span class="nv">@name</span> <span class="no">KV</span><span class="o">.</span><span class="no">BucketSupervisor</span>

  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">_opts</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="ss">:ok</span><span class="p">,</span> <span class="ss">name:</span> <span class="nv">@name</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">start_bucket</span> <span class="k">do</span>
    <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_child</span><span class="p">(</span><span class="nv">@name</span><span class="p">,</span> <span class="p">[])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Supervisor</span><span class="o">.</span><span class="n">init</span><span class="p">([</span><span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="p">],</span> <span class="ss">strategy:</span> <span class="ss">:simple_one_for_one</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Здесь есть два отличия от супервизора, который мы сделали сначала.</p>

<p>Во-первых, было решено дать супервизору локальное имя <code class="highlighter-rouge">KV.BucketSupervisor</code>. Мы могли посылать параметр <code class="highlighter-rouge">opts</code>, полученный в функции <code class="highlighter-rouge">start_link/1</code>, в супервизор, но для простоты мы задали имя прямо в коде. Помните, что такой подход имеет свои минусы. Например, мы не сможем запустить несколько экземпляров <code class="highlighter-rouge">KV.BucketSupervisor</code> во время тестов, они будут конфликтовать по имени. В этом случае, нам стоит позволить всем реестрам использовать один супервизор корзин, и это не будет проблемой, если потомки супервизора <code class="highlighter-rouge">:simple_one_for_one</code> не взаимодействуют друг с другом.</p>

<p>Во-вторых, была определена функция <code class="highlighter-rouge">start_bucket/0</code>, которая запускает корзины, как потомков нашего супервизора <code class="highlighter-rouge">KV.BucketSupervisor</code>. Функция <code class="highlighter-rouge">start_bucket/0</code> – это функция, которую мы будем вызывать вместо прямого вызова функции <code class="highlighter-rouge">KV.Bucket.start_link/1</code> в реестре.</p>

<p>Выполните команду <code class="highlighter-rouge">iex -S mix</code> для запуска консоли, чтобы попробовать наш новый супервизор:</p>

<pre><code class="language-iex">iex&gt; {:ok, _} = KV.BucketSupervisor.start_link([])
{:ok, #PID&lt;0.70.0&gt;}

iex&gt; {:ok, bucket} = KV.BucketSupervisor.start_bucket
{:ok, #PID&lt;0.72.0&gt;}

iex&gt; KV.Bucket.put(bucket, "eggs", 3)
:ok

iex&gt; KV.Bucket.get(bucket, "eggs")
3
</code></pre>

<p>Мы почти готовы к использованию этого супервизора в нашем приложении. Первый шаг – изменить реестр, используя вызов <code class="highlighter-rouge">start_bucket</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">})</span> <span class="k">do</span>
    <span class="k">if</span> <span class="no">Map</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">}}</span>
    <span class="k">else</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">KV</span><span class="o">.</span><span class="no">BucketSupervisor</span><span class="o">.</span><span class="n">start_bucket</span><span class="p">()</span>
      <span class="n">ref</span> <span class="o">=</span> <span class="no">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
      <span class="n">refs</span> <span class="o">=</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="n">names</span> <span class="o">=</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
      <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">{</span><span class="n">names</span><span class="p">,</span> <span class="n">refs</span><span class="p">}}</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Второй шаг – убедиться, что <code class="highlighter-rouge">KV.BucketSupervisor</code> запускается при загрузке приложения. Мы можем сделать это, открыв файл <code class="highlighter-rouge">lib/kv/supervisor.ex</code> и изменив функцию <code class="highlighter-rouge">init/1</code> следующим образом:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">{</span><span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="p">,</span> <span class="ss">name:</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="p">},</span>
      <span class="no">KV</span><span class="o">.</span><span class="no">BucketSupervisor</span>
    <span class="p">]</span>

    <span class="no">Supervisor</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy:</span> <span class="ss">:one_for_one</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Этого достаточно, чтобы тесты проходили, но в приложении есть утечка ресурсов. Когда корзина экстренно завершает работу, супервизор запускает новую на её месте. В конце концов, в этом и заключается роль супервизора!</p>

<p>Однако, когда супервизор перезапускает корзину, реестр не знает об этом. Поэтому у нас будет пустая корзина в супервизоре, к которой никто не может получить доступ! Чтобы решить это, нужер указать, что корзины на самом деле временные. Если они падают, независимо от причины, они не должны быть перезапущены.</p>

<p>Мы можем сделать это, передав опцию <code class="highlighter-rouge">restart: :temporary</code> в строке <code class="highlighter-rouge">use Agent</code>, которая находится в модуле <code class="highlighter-rouge">KV.Bucket</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Agent</span><span class="p">,</span> <span class="ss">restart:</span> <span class="ss">:temporary</span>
</code></pre></div></div>

<p>Давайте также добавим тест в <code class="highlighter-rouge">test/kv/bucket_test.exs</code>, который будет гарантировать, что корзина является временной.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">test</span> <span class="sd">"</span><span class="s2">are temporary workers"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Supervisor</span><span class="o">.</span><span class="n">child_spec</span><span class="p">(</span><span class="no">KV</span><span class="o">.</span><span class="no">Bucket</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">restart</span> <span class="o">==</span> <span class="ss">:temporary</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Этот тест использует функцию <code class="highlighter-rouge">Supervisor.child_spec/2</code>, чтобы получить спецификацию потомка из модуля, затем устанавливает значение перезапуска в <code class="highlighter-rouge">:temporary</code>. Сейчас вы можете задаться вопросом, зачем вообще использовать супервизор, если он никогда не перезапускает своих потомков. Это нужно, потому что супервизоры осуществляют не только перезапуск, они также гарантируют корректный запуск и отключение, особенно в случае падений в дереве супервизора.</p>

<h2 id="деревья-супервизора">Деревья супервизора</h2>

<p>После добавления модуля <code class="highlighter-rouge">KV.BucketSupervisor</code> в качестве потомка модуля <code class="highlighter-rouge">KV.Supervisor</code>, возникла ситуация, при которой супервизоры отслеживают состояние других супервизоров, формируя так называемые «деревья супервизоров».</p>

<p>Каждый раз, когда вы добавляете нового потомка супервизору, важно убедиться, что выбрана правильная стратегия супервизора, а также порядок процессов-потомков. В данном случае мы используем опцию <code class="highlighter-rouge">:one_for_one</code> и модуль <code class="highlighter-rouge">KV.Registry</code> запускается до модуля <code class="highlighter-rouge">KV.BucketSupervisor</code>.</p>

<p>Первый недостаток – проблема правильного порядка. Если модуль <code class="highlighter-rouge">KV.Registry</code> вызывает модуль <code class="highlighter-rouge">KV.BucketSupervisor</code>, тогда модуль <code class="highlighter-rouge">KV.BucketSupervisor</code> должен запускаться раньше модуля <code class="highlighter-rouge">KV.Registry</code>. В противном случае может произойти так, что реестр попытается обратиться к супервизору корзин до того, как он будет запущен.</p>

<p>Второй недостаток связан со стратегией супервизора. Если модуль <code class="highlighter-rouge">KV.Registry</code> умирает, вся информация, связывающая имена модуля <code class="highlighter-rouge">KV.Bucket</code> с процессами корзин, будет потеряна. Кроме того, модуль <code class="highlighter-rouge">KV.BucketSupervisor</code> и все его потомки должны будут также завершить работу – иначе у нас останутся «осиротевшие» процессы.</p>

<p>В свете этих подробностей, нам стоит рассмотреть альтернативные стратегии супервизора. Два других варианта – <code class="highlighter-rouge">:one_for_all</code> и <code class="highlighter-rouge">:rest_for_one</code>. Супервизор, использующий <code class="highlighter-rouge">:rest_for_one</code>, будет перезапускать процессы-потомки, которые были запущены <em>после</em> упавшего потомка. В таком случае мы бы хотели, чтобы модуль <code class="highlighter-rouge">KV.BucketSupervisor</code> завершился, если завершает работу модуль <code class="highlighter-rouge">KV.Bucket</code>. Также при этом нужно поместить супервизор корзин после реестра. А это приведёт к проблеме порядка, которую мы обнаружили двумя абзацами ранее.</p>

<p>Таким образом, у нас остался всего один вариант, на который все надежды – стратегия <code class="highlighter-rouge">:one_for_all</code>: супервизор будет перезапускать всех потомков, при падении любого из них. Это имеет смысл в нашем приложении, т. к. реестр не может работать без супервизора корзин, и супервизор корзин не должен работать без реестра. Давайте переделаем функцию <code class="highlighter-rouge">init/1</code> в модуле <code class="highlighter-rouge">KV.Supervisor</code>, включив данные свойства:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span>
      <span class="no">KV</span><span class="o">.</span><span class="no">BucketSupervisor</span><span class="p">,</span>
      <span class="p">{</span><span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="p">,</span> <span class="ss">name:</span> <span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="p">}</span>
    <span class="p">]</span>

    <span class="no">Supervisor</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy:</span> <span class="ss">:one_for_all</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Чтобы помочь разработчикам запомнить, как работают супервизоры и их удобные функции, <a href="http://benjamintan.io/">Бенджамин Тан Вэй Хао</a> подготовил <a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/Supervisor_CheatSheet.pdf">шпаргалку для модуля <code class="highlighter-rouge">Supervisor</code></a>.</p>

<p>И у нас осталось ещё две темы для обсуждения перед тем, как мы перейдём к следующей главе.</p>

<h2 id="общее-состояние-в-тестах">Общее состояние в тестах</h2>

<p>Недавно мы начали использовать один реестр для одного теста, чтобы быть уверенными в их изолированности:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setup</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">registry</span><span class="p">}</span> <span class="o">=</span> <span class="n">start_supervised</span><span class="p">(</span><span class="no">KV</span><span class="o">.</span><span class="no">Registry</span><span class="p">)</span>
  <span class="p">%{</span><span class="ss">registry:</span> <span class="n">registry</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Т. к. теперь мы изменили наш реестр для использования <code class="highlighter-rouge">KV.BucketSupervisor</code>, который доступен глобально, наши тесты полагаются на этот общий супервизор, хотя каждый тест имеет свой реестр. Вопрос в том, правильно ли это?</p>

<p>Ответ неоднозначен. Нормально полагаться на общее состояние, пока мы зависим только от непересекающихся частей этого состояния. Хотя несколько реестров могут запускать корзины в общем супервизоре корзин, эти корзины и реестры изолированы друг от друга. Мы можем столкнуться только с проблемами параллельного запуска, если будем использовать функции вроде <code class="highlighter-rouge">Supervisor.count_children(KV.Bucket.Supervisor)</code>, которые будут считать все корзины во всех реестрах, потенциально давая нам разные результаты при параллельном запуске тестов.</p>

<p>Т. к. мы пока зависим только от непересекающихся частей супервизора корзин, нам нет смысла беспокоиться о проблемах с параллельным запуском набора тестов. Если это когда-нибудь станет проблемой, мы можем запускать супервизор для каждого теста и передавать его аргументом в функцию реестра <code class="highlighter-rouge">start_link</code>.</p>

<h2 id="инструмент-observer">Инструмент <code class="highlighter-rouge">Observer</code></h2>

<p>Мы определили наше дерево супервизоров, и теперь есть прекрасая возможность познакомиться с инструментом <code class="highlighter-rouge">Observer</code>, который поставляется с Эрлангом. Запустите ваше приложение с помощью <code class="highlighter-rouge">iex -S mix</code> и введите следующее:</p>

<pre><code class="language-iex">iex&gt; :observer.start
</code></pre>

<p>Должен появиться графический интерфейс с множеством информации о вашей системе, начиная от общей статистики и заканчивая графиками загрузки, а также списком всех процессов и приложений.</p>

<p>Во вкладке <strong>Applications</strong> вы увидите все приложения, запущенные параллельно в вашей системе, а также их дерево супервизоров. Вы можете выбрать приложение <code class="highlighter-rouge">kv</code>, чтобы исследовать его дальше:</p>

<p><img src="/docs/images/contents/kv-observer.png" width="640" alt="Observer GUI" /></p>

<p>Кроме того, если вы создаёте новые корзины в терминале, вы увидете новые порождённые процессы дерева супервизоров в окне <code class="highlighter-rouge">Observer</code>:</p>

<pre><code class="language-iex">iex&gt; KV.Registry.create KV.Registry, "shopping"
:ok
</code></pre>

<p>Мы оставим вам дальнейшее исследование возможностей <code class="highlighter-rouge">Observer</code>. Обратите внимание, что двойной клик по процессу в дереве супервизоров покажет больше информации о нём, а также правый клик по процессу посылает сигнал <em>«kill»</em>, прекрасная возможность сэмулировать падения и посмотреть, как супервизор на них отреагирует.</p>

<p>Также, инструменты вроде <code class="highlighter-rouge">Observer</code> – одна из причин, по которой вы захотите всегда использовать процессы внутри дерева супервизоров, даже если они временные, чтобы убедиться в их доступности.</p>

<p>Теперь, когда наши корзины правильно связаны и отслеживаются супервизором, самое время узнать, как мы можем ускорить работу всего приложения.</p>

    </div>
</article>

<nav class="docs_nav pure-g">
    <div class="docs_nav__inner pure-u-1 pure-u-md-3-4">
        <div class="pure-g">
            <div class="docs_nav__column docs_nav__column--prev pure-u-1-3">
                
                    <a href="/docs/mix-otp/supervisor-and-application.html" class="docs_nav__link pure-button">
                        &larr;<span class="h-hidden_mobile"> Назад</span></a>
                
            </div>

            <div class="docs_nav__column docs_nav__column--contents pure-u-1-3">
                <a href="#docsContents" class="docs_nav__link docs_nav__link--contents pure-button">☰</a>
            </div>

            <div class="docs_nav__column docs_nav__column--next pure-u-1-3">
                
                    <a href="/docs/mix-otp/ets.html" class="docs_nav__link pure-button">
                        <span class="h-hidden_mobile">Вперёд </span>&rarr;
                    </a>
                
            </div>
        </div>
    </div>
</nav>

<div id="docsContents" class="modal modal--docs_contents modal--close_backdrop">
    <div class="modal__content">
        <a href="#close" title="Закрыть" class="modal__close">x</a>

        <h2 class="modal__title">Содержание</h2>

        
        <h3 id="руководство-для-начинающих">Руководство для начинающих</h3>
<ul>
  <li><a href="/docs">Введение</a></li>
  <li><a href="/docs/basic-types.html">Базовые типы</a></li>
  <li><a href="/docs/basic-operators.html">Базовые операторы</a></li>
  <li><a href="/docs/pattern-matching.html">Сопоставление с образцом</a></li>
  <li><a href="/docs/case-cond-and-if.html">Конструкции ветвления</a></li>
  <li><a href="/docs/binaries-strings-and-char-lists.html">Двоичные данные, строки и списки символов</a></li>
  <li><a href="/docs/keywords-and-maps.html">Ключевые списки и словари</a></li>
  <li><a href="/docs/modules-and-functions.html">Модули и функции</a></li>
  <li><a href="/docs/recursion.html">Рекурсия</a></li>
  <li><a href="/docs/enumerables-and-streams.html">Перечисления и потоки</a></li>
  <li><a href="/docs/processes.html">Процессы</a></li>
  <li><a href="/docs/io-and-the-file-system.html">Ввод/вывод и файловая система</a></li>
  <li><a href="/docs/alias-require-and-import.html">Директивы <code class="highlighter-rouge">alias</code>, <code class="highlighter-rouge">require</code> и <code class="highlighter-rouge">import</code></a></li>
  <li><a href="/docs/module-attributes.html">Атрибуты модулей</a></li>
  <li><a href="/docs/structs.html">Структуры</a></li>
  <li><a href="/docs/protocols.html">Протоколы</a></li>
  <li><a href="/docs/comprehensions.html">Списковые выражения</a></li>
  <li><a href="/docs/sigils.html">Сигилы</a></li>
  <li><a href="/docs/try-catch-and-rescue.html">Конструкция <code class="highlighter-rouge">try</code>, <code class="highlighter-rouge">catch</code> и <code class="highlighter-rouge">rescue</code></a></li>
  <li><a href="/docs/typespecs-and-behaviours.html">Спецификации типов и поведения</a></li>
  <li><a href="/docs/erlang-libraries.html">Библиотеки Эрланга</a></li>
  <li><a href="/docs/where-to-go-next.html">Куда двигаться дальше</a></li>
</ul>

<h3 id="микс-и-otp">Микс и <code class="highlighter-rouge">OTP</code></h3>
<ul>
  <li><a href="/docs/mix-otp/introduction-to-mix.html">Введение в Микс</a></li>
  <li><a href="/docs/mix-otp/agent.html">Агент</a></li>
  <li><a href="/docs/mix-otp/genserver.html">GenServer</a></li>
  <li><a href="/docs/mix-otp/supervisor-and-application.html">Супервизор и приложение</a></li>
  <li><a href="/docs/mix-otp/dynamic-supervisor.html">Динамический супервизор</a></li>
  <li><a href="/docs/mix-otp/ets.html">ETS</a></li>
  <li><a href="/docs/mix-otp/dependencies-and-umbrella-apps.html">Зависимости и зонтичные проекты</a></li>
  <li><a href="/docs/mix-otp/task-and-gen-tcp.html">Модули <code class="highlighter-rouge">Task</code> и <code class="highlighter-rouge">:gen_tcp</code></a></li>
  <li><a href="/docs/mix-otp/docs-tests-and-with.html">Доктесты, паттерны и оператор <code class="highlighter-rouge">with</code></a></li>
  <li><a href="/docs/mix-otp/distributed-tasks-and-configuration.html">Распределенные задачи и конфигурация</a></li>
</ul>

<h3 id="метапрограммирование">Метапрограммирование</h3>
<ul>
  <li><a href="/docs/meta/quote-and-unquote.html">Конструкции <code class="highlighter-rouge">quote</code> и <code class="highlighter-rouge">unquote</code></a></li>
  <li><a href="/docs/meta/macros.html">Макросы</a></li>
  <li><a href="/docs/meta/domain-specific-languages.html">Предметно-ориентированные языки</a></li>
</ul>

    </div>
</div>



        <footer class="footer">
    &copy; 2020
    / Россия

    <span class="pull-right">Любые мысли и вопросы пишите на <a href="mailto:elixir@wunsh.ru">elixir@wunsh.ru</a>.</span>
</footer>

        <div id="subscribeModal" class="modal">
    <div class="modal__content">
        <a href="#close" title="Close" class="modal__close">x</a>

        <h2 class="modal__title">Ламповая рассылка про&nbsp;Эликсир</h2>

        <p>Один-два раза в&nbsp;неделю присылаем тёплые письма об&nbsp;Эликсире: переводы самых интересных статей до&nbsp;их&nbsp;появления в&nbsp;открытом доступе, анонсы событий и&nbsp;вкусные бонусы.</p>

        <form action="//wunsh.us14.list-manage.com/subscribe/post?u=c81ca3d4693f62db7f7f67c71&amp;id=a192e2dfef" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="pure-form h-tc validate" target="_blank" novalidate>
            <input type="email" value="" name="EMAIL" class="modal__input pure-input-rounded large" id="mce-EMAIL" placeholder="Твоя почта" required>
            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c81ca3d4693f62db7f7f67c71_a192e2dfef" tabindex="-1" value=""></div>

            <input type="submit" value="Присоединиться" name="subscribe" onClick="yaCounter39773490.reachGoal('SUBSCRIBED'); return true" id="mc-embedded-subscribe" class="pure-button button-success large">
        </form>

        <p>Обязательно подтверди почту, перейдя по&nbsp;ссылке в&nbsp;письме, иначе мы&nbsp;не&nbsp;сможем делиться с&nbsp;тобой полезностями.</p>

        <p>Надоедать точно не&nbsp;будем :)</p>
    </div>
</div>

        <script src="/assets/js/vendors/zepto.min.js"></script>

<script>
    if ($(".post--docs").length) {
        $(".footer").addClass("footer--docs")
    }

    $(".modal--close_backdrop").click(function(){
        window.location.hash = "";
    });
</script>

        <!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter39773490 = new Ya.Metrika({
                    id:39773490,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true,
                    ut:"noindex"
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/39773490?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

      </div>
    </div>
  </body>
</html>
