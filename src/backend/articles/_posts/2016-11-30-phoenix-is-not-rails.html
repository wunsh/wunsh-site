---
title: Чем Phoenix отличается от Rails
excerpt: Несмотря на то, что Phoenix во многом использует философию Rails, эти фреймворки разительно отличаются в вопросах реализации.
author: nadezhda
source_url: https://dockyard.com/blog/2015/11/18/phoenix-is-not-rails
source_title: Phoenix is not Rails
source_author: Chris McCord
public: true
tags: [phoenix, rails]
---
<p>На&nbsp;первый взгляд, Phoenix по&nbsp;некоторым признакам схож с&nbsp;Rails. Это побуждает разработчиков начинать его осваивать и&nbsp;сразу&nbsp;же создавать свои проекты для того, чтобы в&nbsp;совершенстве им&nbsp;овладеть. Для достижения желаемого результата потребуется немного больше, чем простое знание общих принципов этих двух фреймворков. Однако Ruby-разработчики, приворожённые внешним сходством Phoenix и&nbsp;Rails, с&nbsp;удовольствием погружаются в&nbsp;новую среду и&nbsp;делают это довольно успешно. К&nbsp;сожалению, это приводит к&nbsp;большим заблуждениям о&nbsp;единообразии Phoenix и&nbsp;Rails, а также&nbsp;к&nbsp;упущению значительных различий их&nbsp;идеологий.</p>
<p>В&nbsp;сообществе Ruby принято считать, что есть Rails-разработчики, а&nbsp;есть Ruby-разработчики. С&nbsp;Phoenix такого раскола не&nbsp;предвидится. Хотя Phoenix, безусловно, имеет свой механизм абстракций, написание Phoenix-приложения&nbsp;&mdash; это написание приложения на&nbsp;Elixir. Тестирование Phoenix-кода&nbsp;&mdash; это тестирование Elixir-функций. В&nbsp;данной статье приводится обоснование этих принципов путём выявления сходств и&nbsp;различий фреймворков Phoenix и&nbsp;Rails.</p>
<h2>Сходства</h2>
<p>Большую часть поклонников Phoenix составляют Rails-разработчики, поэтому озвучим несколько основных особенностей, которые принёс с собой фреймворк Rails.</p>
<ul>
    <li>
        <p>Нацеленность на&nbsp;высокие показатели скорости разработки как на&nbsp;клиентской, так и&nbsp;на&nbsp;серверной стороне.</p>
    </li>
    <li>
        <p>Стандартная структура файлов и&nbsp;каталогов, хотя Phoenix попросту берёт за&nbsp;основу структуру Elixir-приложений.</p>
    </li>
    <li>
        <p>MVC&nbsp;во главе с&nbsp;маршрутизатором (правда, Phoenix в&nbsp;своей архитектуре плавно сворачивает в&nbsp;сторону функциональной парадигмы).</p>
    </li>
    <li>
        <p>Стандартный стек технологий с&nbsp;поддержкой реляционных баз данных (sqlite3&nbsp;в Rails, PostgreSQL в&nbsp;Phoenix).</p>
    </li>
    <li>
        <p>Наилучшие подходы к&nbsp;безопасности прямо из&nbsp;коробки.</p>
    </li>
    <li>
        <p>Встроенные механизмы для тестирования приложений.</p>
    </li>
</ul>
<h2>Различия</h2>
<p>Несмотря на&nbsp;некоторые сходства, фреймворки Phoenix и&nbsp;Rails существенно различаются. Далеко не&nbsp;каждая среда выполнения готова предложить подход, который реализует Phoenix. Он&nbsp;проявляется в&nbsp;особенностях структуры приложения, способности к&nbsp;восстановлению после отказа, отладке системы или установлении связи с&nbsp;клиентом. Принципы OTP и&nbsp;характерные черты Elixir объединяются в&nbsp;Phoenix таким образом, что Phoenix-приложение является всего лишь частью более мощной инфраструктуры. Такое расхождение с&nbsp;Rails накладывает свой отпечаток на&nbsp;стек.</p>
<h3>Приложения</h3>
<p>Начнём с&nbsp;того, что понятия &laquo;Phoenix-приложение&raquo; не&nbsp;существует. Проекты Phoenix прежде всего Elixir-приложения, которые строятся на&nbsp;Phoenix для обеспечения дополнительной функциональности. Это означает, что существует только один путь для создания, запуска и&nbsp;развёртывания приложения. И&nbsp;это путь Elixir. Итак, почему&nbsp;же Phoenix выигрывает?</p>
<h4>Факт &#8470;&nbsp;1. Никаких синглтонов</h4>
<p>В&nbsp;Rails всё реализуется в&nbsp;виде единственного приложения, получить доступ к&nbsp;которому можно с&nbsp;помощью <code class="elixir">Rails.application</code>. Rails командует парадом: запускает приложение, создаёт конфигурации и&nbsp;даже выполняет задачи из&nbsp;коммандной строки. Данному подходу свойственно такое ограничение, как невозможность одновременного запуска двух Rails-приложений. Если&nbsp;же в&nbsp;этом существует необходимость, придётся каждое из&nbsp;них превратить в&nbsp;отдельный Engine и&nbsp;научиться с&nbsp;ними работать.</p>
<p>Всё глобальное чуждо для Phoenix. Никаких монолитов. Созданное Phoenix-приложение включает в&nbsp;себя одну точку входа (Endpoint), один маршрутизатор (Router) и&nbsp;один сервер PubSub. Но&nbsp;при желании этот список можно расширить. Так как глобального состояния или глобального сервера не&nbsp;существует, приложение можно разбивать на&nbsp;части по&nbsp;мере роста его инфраструктуры.</p>
<h4>Факт &#8470;&nbsp;2. Запуск и&nbsp;остановка</h4>
<p>С&nbsp;точки зрения Elixir, проект представляет собой совокупность небольших компонуемых между собой приложений, которые запускаются и&nbsp;останавливаются как единое целое. Процесс запуска обычно протекает следующим образом (в&nbsp;качестве примера приведён Phoenix):</p>
<ol>
    <li>
        <p>В&nbsp;каждом приложении имеется спецификация, в&nbsp;которой могут быть указаны модули, вызываемые после инициализации приложения:</p>
        {% highlight elixir %}def application do
[mod: {Phoenix, []},
 applications: [:plug, :poison, :logger, :eex],
...]
end{% endhighlight %}
    </li>
    <li>
        <p>В&nbsp;указанных модулях вызывается функция <code class="elixir">start/2</code>:</p>
        {% highlight elixir %}
defmodule Phoenix do
  def start(_type, _args) do
    ...
    Phoenix.Supervisor.start_link
  end
end{% endhighlight %}
    </li>
    <li>
        <p>Функция <code class="elixir">start/2</code> возвращает идентификатор контролируемого супервизором процесса (<code class="elixir">Phoenix.Supervisor.start_link</code> в&nbsp;примере выше).</p>
    </li>
</ol>
<p>Нечто похожее происходит и&nbsp;при остановке приложения. Независимо от&nbsp;того, используете вы&nbsp;Phoenix или нет, каждое приложение содержит свой собственный механизм старта/остановки.</p>
<p>Сложный и&nbsp;требующий использования расширений процесс инициализации Rails-приложения послужит ярким контрастом единому последовательному набору действий в&nbsp;Phoenix. Для версии Rails&nbsp;4.2.2:</p>
{% highlight elixir %}$ rails c
Loading development environment (Rails 4.2.2)
irb(main):001:0> Rails.application.initializers.length
=> 74{% endhighlight %}
<p>Получаем целых 74&nbsp;фрагмента кода (блоков Ruby), беспорядочно разбросанных по&nbsp;многочисленным файлам! Крайне важно контролировать логику инициализации, чтобы знать, что конкретно запускается в&nbsp;приложении, и&nbsp;обеспечивать быструю загрузку.</p>
<h4>Факт &#8470;&nbsp;3. Мониторинг и&nbsp;интроспекция</h4>
<p>Разделяя приложение на&nbsp;несколько более мелких, вы&nbsp;обеспечиваете управление, отказоустойчивость и&nbsp;интроспекцию запущенной системы. При помощи инструмента Observer можно без лишних усилий представить работу приложений по&nbsp;отдельности или в&nbsp;качестве единого целого:</p>
<img src="https://i.imgur.com/SehijaI.png" alt="Erlang Observer" class="article-image">
<p>Главное преимущество в&nbsp;том, что проект запускается как единое приложение, при этом его можно разбить на&nbsp;несколько более мелких приложений, что актуально как для запуска на&nbsp;одной ноде, так и&nbsp;для сервис-ориентируемой архитектуры. Среда выполнения не&nbsp;требует от&nbsp;вас никаких вложений. Она построена на&nbsp;проверенных и&nbsp;надёжных подходах. Собственно, наглядный пример этого можно увидеть в&nbsp;одной из&nbsp;глав книги Programming Phoenix.</p>
<h3>Жизненный цикл запроса</h3>
<p>Phoenix показывает отличную производительность &laquo;из&nbsp;коробки&raquo;, что можно легко доказать, проведя бенчмарки. Жизненный цикл запроса в&nbsp;корне отличается от&nbsp;цикла, реализованного в&nbsp;Rails при помощи Rack.</p>
<h4>Факт &#8470;&nbsp;4. Читабельный код</h4>
<p>Явное лучше неявного. Исключений из&nbsp;этого правила практически нет. Phoenix в&nbsp;большинстве своём поддерживает концепцию &laquo;явного&raquo;. К&nbsp;примеру, в&nbsp;процессе написания приложения на&nbsp;Phoenix, можно просмотреть все плаги, через которые проходит запрос, в&nbsp;файле <code class="elixir">lib/my_app/endpoint.ex</code>. Phoenix представляет все плаги в&nbsp;явном виде, в&nbsp;то&nbsp;время как Rais выделяет Rack middlewares в&nbsp;отдельную часть приложения. Таким образом, просмотрев плаги, можно очень быстро составить себе представление о&nbsp;жизненном цикле запроса.</p>
{% highlight elixir %}defmodule MyApp.Endpoint do
  use Phoenix.Endpoint, otp_app: :my_app

  socket "/socket", MyApp.UserSocket
  plug Plug.Static, at: "/", from: :my_app, gzip: false, only: ~w(css images js)
  plug Plug.RequestId
  plug Plug.Logger
  plug Plug.Parsers, parsers: [:urlencoded, :multipart, :json], pass: ["*/*"]
  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, store: :cookie
  plug MyApp.Router
end{% endhighlight %}
<p>Запрос берёт своё начало в&nbsp;точке входа, пробегает через &laquo;основной middleware&raquo;, представленный в&nbsp;явном виде в&nbsp;форме плага, а&nbsp;затем передаётся в&nbsp;маршрутизатор, который сам по&nbsp;себе также является плагом. В&nbsp;маршрутизаторе запрос проходит ещё одну пачку плагов, после чего направляется в&nbsp;контроллер, который (бинго!) тоже представляет собой плаг. Единственная абстракция, обхватывающая все уровни стека, позволяет представить жизненный цикл запроса настолько явно, насколько это вообще возможно. Это также облегчает интеграцию с&nbsp;пакетами от&nbsp;сторонних разработчиков.</p>
<p>Проведём сравнение двух схожих контроллеров, чтобы увидеть, каким образом функциональный подход с&nbsp;плагами делает код Phoenix более читабельным:</p>
{% highlight elixir %}# controller.rb

before_action :find_user

def show do
  @post = @user.posts.find(params[:id])
end

def find_user
  @user = User.find(params[:user_id])
end{% endhighlight %}

{% highlight elixir %}#controller.ex

plug :find_user

def show(conn, %{"id" => id}) do
  post = conn.assigns.user |> assoc(:posts) |> Repo.get(id)
  render conn, "show.html", post: post
end

defp find_user(conn, _) do
  assign(conn, :user, Repo.get(User, conn.params["user_id"]))
end{% endhighlight %}
<p>Опытным Rails-разработчикам известно, что <code class="elixir">show</code> неявно вызывает <code class="elixir">render "show.html"</code>. Даже если&nbsp;бы это делалось явно, немногие Rails-разработчики обращают внимание на&nbsp;то, что все объявленные в&nbsp;экземпляре контроллера переменные копируются в&nbsp;экземпляр представления, что только усложняет процесс программирования. Соглашения важнее конфигураций&nbsp;&mdash; это, конечно, хороший принцип, но&nbsp;есть некая грань, где неявная реализация сводит на&nbsp;нет ясность кода. Phoenix обеспечивает идеальное соотношение ясности кода и&nbsp;удобства использования API. Кроме того, программистам с&nbsp;объектно-ориентированным складом ума нельзя забывать о&nbsp;хэше параметров <code class="elixir">params</code>, объектах <code class="elixir">request</code> и&nbsp;других переменных, заданных неявно в&nbsp;фильтрах <code class="elixir">before_action</code>. В&nbsp;Phoenix всё это задаётся явным образом. Структура <code class="elixir">conn</code> выступает в&nbsp;качестве структуры данных и&nbsp;средства связи с&nbsp;сервером. Данные передаются через плаги&nbsp;&mdash; объединённые в&nbsp;цепочку функции, которые проводят некие трансформации над запросом&nbsp;и, если нужно, возвращают ответ.</p>
<h4>Факт &#8470;&nbsp;5. Лёгкое тестирование</h4>
<p>Функциональное программирование и&nbsp;плаги позволяют проводить изолированное или интеграционное тестирование контроллеров простой передачей структуры <code class="elixir">conn</code> в&nbsp;цепочку плагов и&nbsp;анализом полученных результатов. Кроме того, действия контроллера в&nbsp;Phoenix&nbsp;&mdash; всего лишь функции, не&nbsp;имеющие неявно заданных переменных. Необходимо изолированно протестировать контроллер? Просто вызываем функцию:</p>
{% highlight elixir %}test "sends 404 when user is not found" do
  conn = MyController.show(conn(), %{"id" => "not-found"})
  assert conn.status == 404
end{% endhighlight %}
<p>Благодаря функциональному программированию, построение экземпляров контроллеров проходит без каких-либо трудностей. А&nbsp;если нужно провести интеграционное тестирование через точку входа, то&nbsp;фреймворку Phoenix достаточно лишь вызвать цепочку функций:</p>
{% highlight elixir %}test "shows users" do
  conn = get conn(), "/users/123"
  assert %{id: "123"} = json_response(conn, :ok)
end{% endhighlight %}
<p>Представления в&nbsp;Phoenix устроены аналогичным образом: они состоят из&nbsp;функций, среди которых нет каких-либо скрытых данных.</p>
<h4>Факт &#8470;&nbsp;6. Удобно делиться кодом</h4>
<p>Метод, написанный для Rails-контроллера не&nbsp;получится так просто перенести в&nbsp;Rack, потому как он&nbsp;зависит от&nbsp;множества внутренних переменных контроллера.</p>
<p>Так как плаги&nbsp;&mdash; это всего лишь функции, то&nbsp;нам известны их&nbsp;входные и&nbsp;выходные параметры. Для всего стека технологий HTTP, будь&nbsp;то точка входа, маршрутизатор или контроллер, существует единое абстрактное представление. Покажем на&nbsp;примере, как использовать плаг <code class="elixir">AdminAuthentication</code> для всех запросов <code class="elixir">"/admin"</code>, а&nbsp;также для отдельного контроллера <code class="elixir">DashboardController</code>. Плаг на&nbsp;уровнях абстракции маршрутизатора и&nbsp;контроллера будет одним и&nbsp;тем&nbsp;же:</p>
{% highlight elixir %}defmodule MyApp.Router do
  pipeline :browser do
    plug :fetch_session
    ...
    plug :protect_from_forgery
  end

  pipeline :admin do
    plug AdminAuthentication
  end

  scope "/" do
    get "/dashboard", DashboardController
  end

  scope "/admin" do
    pipe_through [:browser, :admin] # plugged for all routes in this scope

    resources "/orders", OrderController
  end
end

defmodule MyApp.DashboardController do
  plug AdminAuthentication # plugged only on this controller

  def show(conn, _params) do
    render conn, "show.html"
  end
end{% endhighlight %}
<p>Так как плаги используются на&nbsp;всех уровнях стека, то&nbsp;можно подключить плаг <code class="elixir">AdminAuthentication</code> в&nbsp;маршрутизатор и&nbsp;контроллер для осуществления детального контроля доступа. В&nbsp;Rails для этого можно наследоваться от&nbsp;<code class="elixir">AdminController</code>, но&nbsp;тогда теряется прозрачность применяемых преобразований объекта запроса. Придётся прошерстить дерево наследования для того, чтобы выяснить нужные связи и&nbsp;отношения. В&nbsp;Phoenix цепочки функций маршрутизатора позаботятся о&nbsp;чётких и&nbsp;лаконичных запросах.</p>
<h3>Каналы</h3>
<p>Phoenix изначально создавался для укрощения современных, высоконагруженных, взаимодействующих в&nbsp;реальном времени веб-систем. Каналы предоставляют приложению независимые от&nbsp;протокола передачи данных соединения, работающие в&nbsp;режиме реального времени, которые могут обеспечить обслуживание нескольких миллионов клиентов на&nbsp;одном сервере. В&nbsp;Rails&nbsp;же функционал реального времени всегда отходил на&nbsp;второй план.</p>
<img src="https://i.imgur.com/7CHc1Lh.png" alt="Phoenix vs Rails channels" class="article-image">
<p> </p>
<h4>Факт &#8470;&nbsp;7. Веб не&nbsp;стоит на&nbsp;месте</h4>
<p>Каналы Phoenix направлены на&nbsp;веб за&nbsp;пределами браузера. Уже сейчас веб включает в&nbsp;себя <em>соединённые друг с&nbsp;другом устройства</em> (телефоны, часы, умная электроника), а&nbsp;не&nbsp;ограничивается лишь браузером. Для этого нужен фреймворк, который смог&nbsp;бы развиваться, подстраиваясь под новые изменения и&nbsp;протоколы. Именно поэтому каналы являются независимыми от&nbsp;протокола передачи данных и&nbsp;имеют родные клиенты под платформы iOS, Android и&nbsp;Windows. Всё это можно увидеть в&nbsp;действии, запустив чат-приложение Phoenix в&nbsp;браузере, на&nbsp;iPhone и&nbsp;Apple Watch.</p>
<h4>Факт &#8470;&nbsp;8. Меньше зависимостей&nbsp;&mdash; больше производительности</h4>
<p>Относительно недавняя разработка для внедрения функционала реального времени в&nbsp;Rails&nbsp;&mdash; Action Cable&nbsp;&mdash; привносит в&nbsp;приложение целый список зависимостей: Faye, Celluloid, EventMachine, Redis и&nbsp;другие. Так как Phoenix запускается на&nbsp;виртуальной машине Erlang, он&nbsp;обладает встроенным функционалом реального времени среды выполнения. Поддержка средой выполнения распределенных вычислений позволяет фреймворку Phoenix для использования PubSub обойтись без Redis или подобных зависимостей.</p>
<h3>Именование</h3>
<p>Phoenix не&nbsp;требует строгого соблюдения соглашения об&nbsp;именовании, как это делает Rails.</p>
<h4>Факт &#8470;&nbsp;9. Лёгкость в&nbsp;изучении</h4>
<p>В&nbsp;Phoenix имена модулей не&nbsp;привязываются к&nbsp;имени файла. В&nbsp;Rails необходимо поместить контроллер <code class="elixir">UsersController</code> в&nbsp;файл под названием <code class="elixir">users_controller.rb</code>. Да, в&nbsp;таких соглашениях нет ничего плохого, но&nbsp;с&nbsp;Phoenix можно просто о&nbsp;них забыть. Мы&nbsp;отдаём свой голос за&nbsp;адекватные настройки по&nbsp;умолчанию, достаточно гибкие по&nbsp;отношению к&nbsp;индивидуальным требованиям. Присвоение имён вызывает большие трудности у&nbsp;тех, кто сначала изучил Rails, а&nbsp;потом попытался написать приложение на&nbsp;Ruby. В&nbsp;Rails для получения из&nbsp;каталога приложения всех файлов с&nbsp;именем, соответствующим соглашению о&nbsp;присвоении имён классу, используется метод <code class="elixir">const_missing</code>. В&nbsp;связи с&nbsp;этим для разработчиков, желающих выйти за&nbsp;пределы Rails, процесс осуществления запроса файлов в&nbsp;обычном Ruby-приложении окутан тайной.</p>
<p>В&nbsp;Phoenix включена директория &laquo;web&raquo;, куда помещаются контроллеры, представления и&nbsp;т.&nbsp;п., но&nbsp;существует она только ради перезагрузки кодовой базы, что воплощает в&nbsp;жизнь концепцию разработки через непрерывное обновление страницы.</p>
<p>Phoenix не&nbsp;различает единственного и&nbsp;множественного числа имён. Правила формирования имён в&nbsp;Rails ставят как начинающих, так и&nbsp;продвинутых разработчиков в&nbsp;тупик: модели называют только в&nbsp;единственном числе, контроллеры&nbsp;&mdash; во&nbsp;множественном, URL-хелперы стерпят и&nbsp;то, и&nbsp;другое, и&nbsp;так далее. В&nbsp;Phoenix, как и&nbsp;в&nbsp;Elixir, для имён используется только единственное число. Можно называть таблицы и&nbsp;пути маршрутов во&nbsp;множественном числе, но&nbsp;они задаются явно в&nbsp;рамках системы.</p>
<h3>Ассеты</h3>
<p>Для работы со&nbsp;статическими ассетами в&nbsp;Phoenix по&nbsp;умолчанию используется инструмент brunch, но&nbsp;также существует возможность подключить свой собственный JavaScript-сборщик вместо его написания специально под фреймворк (как это происходит в&nbsp;Rails в&nbsp;случае с&nbsp;его Asset Pipeline). Phoenix также более эффективно использует канальный уровень для предоставления возможности перезагрзуки изменённого кода прямо из&nbsp;коробки.</p>
<h4>Факт &#8470;&nbsp;10. Будущее за&nbsp;ES6/ES2015</h4>
<p>Phoenix содействует развитию ES6/ES2015 вместо CoffeeScript, по&nbsp;умолчанию поддерживая в&nbsp;новых проектах ES2015. CoffeeScript уже выполнил свою главную цель по&nbsp;продвижению индустрии вперёд. ES2015 и&nbsp;его первоклассные транспиляторы&nbsp;&mdash; это следующий шаг.</p>
<h4>Факт &#8470;&nbsp;11. Разработка через непрерывное тестирование</h4>
<p>Phoenix способен обеспечивать возможность непрерывной перезагрузки кода при внесении изменений. Файлы с&nbsp;расширениями <code>.js</code> или <code>.css</code> автоматически перезагружаются в&nbsp;браузере после внесения в&nbsp;них изменений. Однажды попробовав эту опцию, вы&nbsp;вряд&nbsp;ли сможете без неё обойтись.</p>
<h2>Заключение</h2>
<p>Независимо от&nbsp;того, каким языком вы&nbsp;владеете, вы&nbsp;ещё увидите, как Phoenix, основанный на&nbsp;лучших принципах своих предшественников, вместе с&nbsp;Elixir пробьют себе путь к&nbsp;пьедесталу современной веб-разработки.</p>
