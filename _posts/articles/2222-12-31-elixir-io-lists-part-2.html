---
title: "Списки ввода-вывода в&nbsp;Elixir. Часть&nbsp;2: применение в&nbsp;Phoenix"
excerpt: В этой статье рассказывается об использовании структуры под названием списки ввода-вывода в Phoenix Framework.
author: nadezhda
source_url: https://www.bignerdranch.com/blog/elixir-and-io-lists-part-2-io-lists-in-phoenix/
source_author: Nathan Long
---
<p>В&nbsp;<a href="{% post_url 2222-12-31-elixir-io-lists-part-1 %}">предыдущей части</a> мы&nbsp;рассмотрели, как использование списков ввода-вывода в&nbsp;Elixir упрощает работу над реализацией вывода данных и&nbsp;уменьшает расход памяти.</p>
<p>Это отличное решение для создания файлов, но&nbsp;оно едва&nbsp;ли подойдет для веб-приложений. Любая веб-страница содержит динамические элементы: имя текущего пользователя, список недавних постов или изображение товаров в&nbsp;корзине.</p>
<p>Но&nbsp;эти динамические фрагменты оборачиваются в&nbsp;разметку, которая всегда выглядит одинаково: например, каждый товар помещается&nbsp;в <code>&lt;div class=&quot;product&quot;&gt;</code>. А&nbsp;меню, шапка и&nbsp;подвал, скорее всего, содержат одни и&nbsp;те&nbsp;же большие куски HTML-кода.</p>
<p>Предположим, имеется шаблон с&nbsp;именем <code>users/index.html.eex</code>, который выглядит так:</p>
<p><img src="https://habrastorage.org/files/ff1/952/29c/ff195229c36642a19b0f485ce9cff8fd.png"/></p>
<p><p>Эти строки понадобятся нам снова и&nbsp;снова, а&nbsp;выделенный текст вообще никогда не&nbsp;меняется:</p>
<img src="https://habrastorage.org/files/089/9bd/6d8/0899bd6d87874be5abefb08fcba8d9e5.png"/></p>
<p>Большинство веб-фреймворков осуществляют конкатенацию статической разметки и&nbsp;динамических данных в&nbsp;одну большую строку ответа. Реализовать такую конкатенацию не&nbsp;так то&nbsp;просто, да&nbsp;и&nbsp;сборщику мусора при этом придётся хорошенько поработать.</p>
<p>Вместо всего этого Phoenix:</p>
<ul>
    <li>
        <p>загружает все шаблоны из&nbsp;директории шаблонов на&nbsp;этапе компиляции;</p>
    </li>
    <li>
        <p>находит среди них <code>users/index.html.eex</code>;</p>
    </li>
    <li>
        <p>использует EEx для компиляции шаблона в&nbsp;функцию вместе с&nbsp;его макетом и&nbsp;фрагментами;</p>
    </li>
    <li>
        <p>приказывает EEx сделать так, чтобы эта функция создавала и&nbsp;возвращала не&nbsp;строки, а&nbsp;списки ввода-вывода;</p>
    </li>
    <li>
        <p>хранит функцию рендеринга шаблона в&nbsp;виде <code>UsersView.render(&quot;index.html&laquo;, assigns)</code>;</p>
    </li>
</ul>
<p>Созданная функция будет выглядеть примерно так:</p>
{% highlight elixir %}
defmodule MyApp.SomeView do
  defp(index.html(var!(assigns))) do
    _ = var!(assigns)
    {:safe, [(
      tmp1 = ["" | "<h1>Listing Users</h1>\n\n<ul>\n  "]
      [tmp1 | case(for(user <- Phoenix.HTML.Engine.fetch_assign(var!(assigns), :users)) do
        {:safe, [(
          tmp1 = [(
            tmp1 = ["" | "\n    <li> "]
            [tmp1 | case(user.first_name()) do
              {:safe, data} ->
                data
              bin when is_binary(bin) ->
                Plug.HTML.html_escape(bin)
              other ->
                Phoenix.HTML.Safe.to_iodata(other)
            end]
          ) | " ("]
          [tmp1 | case(user.id()) do
            {:safe, data} ->
              data
            bin when is_binary(bin) ->
              Plug.HTML.html_escape(bin)
            other ->
              Phoenix.HTML.Safe.to_iodata(other)
          end]
        ) | ")</li>\n  "]}
      end) do
        {:safe, data} ->
          data
        bin when is_binary(bin) ->
          Plug.HTML.html_escape(bin)
        other ->
          Phoenix.HTML.Safe.to_iodata(other)
      end]
    ) | "\n</ul>\n\nThat's all!\n"]}
  end

  def(render("index.html", assigns)) do
    index.html(assigns)
  end
end
{% endhighlight %}
<p>Отметим, что в&nbsp;этой функции присутствуют строковые литералы вроде <code>&lt;h1&gt;Listing Users&lt;/h1&gt;\n\n&lt;ul&gt;\n</code> и <code>\n &lt;li&gt;</code>. Это одни и&nbsp;те&nbsp;же иммутабельные строки, которые хранятся в&nbsp;одних и&nbsp;тех&nbsp;же ячейках памяти и&nbsp;запрос за&nbsp;запросом появляются в&nbsp;возвращаемом списке ввода-вывода.</p>
<p>После запуска функция возвратит такой список ввода-вывода:</p>
{% highlight elixir %}
[[["" | "<h1>Listing Users</h1>\n\n<ul>\n  "],
    [[[[["" | "\n    <li>"] | "Jane"] | " ("] | "1"] | ")</li>\n  "],
    [[[[["" | "\n    <li>"] | "Joe"] | " ("] | "2"] | ")</li>\n  "]] |
    "\n</ul>\n\nThat's all!\n"]
{% endhighlight %}
<p>Странный список, не&nbsp;находите? Всё потому, что это &laquo;неправильный&raquo; список.</p>
<p>Списки обычно составляются путём добавления новых элементов в&nbsp;конец:</p>
{% highlight elixir %}
list = []           # => []
list = ["C" | list] # => ["C"]
list = ["B" | list] # => ["B", "C"]
list = ["A" | list] # => ["A", "B", "C"]
{% endhighlight %}
<p>Каждый элемент этого списка сам по&nbsp;себе тоже представляет собой список, первый элемент которого&nbsp;&mdash; указатель на&nbsp;строку, а&nbsp;последний элемент&nbsp;&mdash; указатель на&nbsp;следующий список. Последний список пустой (в&nbsp;примере его нет). Как&nbsp;же много списков!</p>
<p>Можно ещё сделать так:</p>
{% highlight elixir %}
list = ["A" | "B"]  # => ["A" | "B"]
{% endhighlight %}
<p>Этот список &laquo;неправильный&raquo;, так как его первый элемент указывает на&nbsp;&laquo;A&raquo;, а&nbsp;последний указывает <strong>не&nbsp;на&nbsp;список</strong>, а&nbsp;на&nbsp;&laquo;B&raquo;.</p>
<p>Многие функции, ожидающие передачи списков, будут прерваны при получении &laquo;неправильного&raquo; списка, поэтому обычно их&nbsp;лучше вообще не&nbsp;использовать. Но&nbsp;так как единственное, что мы&nbsp;сегодня будем делать с&nbsp;этими списками,&nbsp;&mdash; это оборачивать их&nbsp;в&nbsp;другие списки, а&nbsp;затем записывать их&nbsp;в&nbsp;сокет, &laquo;неправильные&raquo; списки позволят избежать выделения памяти под такое большое количество данных.</p>
<p>Что&nbsp;ж, идём дальше.</p>
<p>А&nbsp;дальше как раз происходит самое интересное: список ввода-вывода передаётся процессу веб-сервера, который выводит его пользователю, вызывая в&nbsp;сетевом сокете функцию writev. <strong>Ответ на&nbsp;запрос формируется в&nbsp;окончательном виде только в&nbsp;буфере сокета.</strong></p>
<p>Напомню, что минимальное требование для отправки ответа&nbsp;&mdash; скопировать каждый байт ответа в&nbsp;сокет. Это всё, что делает Phoenix при реализации выбранного способа рендеринга представлений.</p>
<h2>Кэширование</h2>
<p>Описанный выше способ построения ответов обладает ещё одним преимуществом. Помните тот пример шаблона, который содержит строки, повторяющиеся в&nbsp;последующем коде снова и&nbsp;снова?</p>
<p><img src="https://habrastorage.org/files/089/9bd/6d8/0899bd6d87874be5abefb08fcba8d9e5.png"/></p>
<p>Мы&nbsp;уже видели, как функция, которую Phoenix компилирует для рендеринга этого шаблона, всё время использует одни и&nbsp;те&nbsp;же строки, просто добавляя в&nbsp;список ввода-вывода необходимые динамические компоненты. Фактически это не&nbsp;что иное, как кэширование представлений.</p>
<p>Наверняка вы&nbsp;уже имели дело с&nbsp;веб-фреймворками, производящими рендеринг представлений при помощи конкатенации. Они пытаются компенсировать низкую скорость своей работы наличием различных способов кэширования представлений и&nbsp;фрагментов. Вместе с&nbsp;тем они вынудят вас заняться поиском решения одной из&nbsp;сложнейших проблем информатики&nbsp;&mdash; проблемы инвалидации кэша. Следует учитывать, что контент веб-страницы постоянно меняется.</p>
<p>К&nbsp;примеру, пост блога может обновиться в&nbsp;базе данных. Проблему можно решить, поставив ограничение по&nbsp;времени (кэшировать нужный фрагмент поста в&nbsp;течение одного часа) или привязав кэш представления к&nbsp;состоянию базы данных. Например, HTML-код поста блога и&nbsp;комментариев к&nbsp;нему можно поместить в&nbsp;кэш, но&nbsp;тогда, если в&nbsp;пост или комментарии будут внесены изменения, изменится имя автора поста или имя автора комментария, представление необходимо будет рендерить снова. Такие&nbsp;же правила актуальны и&nbsp;для кэширования матрёшкой в&nbsp;Rails.</p>
<p>Нужно также иметь в&nbsp;виду, что элементы страницы для каждого пользователя могут быть разными. Например, адрес электронной почты пользователя или список рекомендованных товаров. Эту проблему можно решить путём создания ключей кэша отдельно для каждого пользователя, как это показано в&nbsp;<noindex><a href="https://docs.djangoproject.com/en/1.10/topics/cache/#template-fragment-caching" rel="noreferrer nofollow">документации Django</a></noindex>, или путём кэширования некой общей версии и&nbsp;добавления персонализированного контента после загрузки страницы с&nbsp;помощью Javascript, как сделано в&nbsp;<noindex><a href="http://railscasts.com/episodes/169-dynamic-page-caching?autoplay=false" rel="noreferrer nofollow">этом</a></noindex> примере. Ну&nbsp;или попробовать вообще обойтись без кэширования.</p>
<p>В&nbsp;любом случае только вам решать, какие части представления стоит кэшировать и&nbsp;при каких обстоятельствах кэш будет считаться валидным. Чем чаще обновляется контент и&nbsp;чем больше он&nbsp;содержит персонализированной информации, тем больше места он&nbsp;занимает в&nbsp;хранилище кэша.</p>
<p>А&nbsp;я&nbsp;разве не&nbsp;говорил, что вам потребуется хранилище кэша? Вам самим придётся решить, где выделить место для кэша: в&nbsp;оперативной памяти, в&nbsp;файловой системе или во&nbsp;внешней базе данных, а&nbsp;потом разбираться со&nbsp;всеми последствиями своего решения.</p>
<p>Не&nbsp;хочу показаться грубым, но&nbsp;все грамотные разработчики прикладывают немало усилий, чтобы кэширование представлений происходило легко и&nbsp;удобно, но&nbsp;даже при существующем множестве решений здесь всё ещё есть над чем поработать.</p>
<p>Phoenix&nbsp;же, напротив, использует простую и&nbsp;универсальную модель кэширования представлений<strong>: кэшируются только статические элементы шаблона, а&nbsp;при изменении файла шаблона данные в&nbsp;кэше аннулируются. Вот и&nbsp;вся схема.</strong></p>
<p>Так как динамические элементы представления (например, список заголовков постов блога в&nbsp;базе данных) не&nbsp;кэшируются, то&nbsp;нужно передать эти данные функциям представления во&nbsp;время рендеринга. Если запросы к&nbsp;базе данных&nbsp;&mdash; узкое место в&nbsp;производительности приложения, то&nbsp;можно просто кэшировать результаты. Воспользуйтесь, к&nbsp;примеру, <noindex><a href="https://www.postgresql.org/docs/current/static/rules-materializedviews.html" rel="noreferrer nofollow">материализованным представлением</a></noindex>, и&nbsp;специальный процесс будет периодически обновлять результаты. Но&nbsp;это уже никак не&nbsp;связано с&nbsp;шаблонами. Рендеринг представлений в&nbsp;Phoenix происходит так быстро, что задумываться о&nbsp;кэшировании полученных страниц просто нет времени.</p>
<h2>Дисклеймер</h2>
<p>Прежде чем перейти к&nbsp;выводам, я&nbsp;хотел&nbsp;бы немного поговорить о&nbsp;системных вызовах.</p>
<p>В&nbsp;предыдущей части статьи было показано, как виртуальная машина BEAM объединяет короткие строки (длиной менее 64&nbsp;байт), помещая их&nbsp;в&nbsp;аргументы функции <code>writev</code>. Если провести трассировку Phoenix-приложения, то&nbsp;вряд можно увидеть, чтобы каждый тег <code>&lt;li&gt;</code> передавался в&nbsp;функцию <code>writev</code> в&nbsp;качестве отдельного аргумента. Но&nbsp;<code>writev</code> всё&nbsp;же используется в&nbsp;сокете.</p>
<p>Вот мой пример трассировки Phoenix-приложения, в&nbsp;шаблонах которого присутствуют очень длинные строки:</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2016/10/phoenix_writev.png" alt="Writev"></p>
<p>Две очень длинные строки, которые я&nbsp;выделил синим, повторяются в&nbsp;шаблоне несколько раз. При записи ответа в&nbsp;сокет, сервер Cowboy всё время ссылается в&nbsp;памяти на&nbsp;одни и&nbsp;те&nbsp;же строки. Строка, выделенная красным, состоит из&nbsp;открывающего HTML-тега и&nbsp;неких неизменяемых данных. На&nbsp;снимке экрана она встречается только один раз, хотя на&nbsp;самом деле в&nbsp;последующих запросах она считывалась снова и&nbsp;снова с&nbsp;одного из&nbsp;того&nbsp;же адреса памяти.</p>
<p>Но&nbsp;независимо от&nbsp;того, как BEAM записывает ответы Phoenix в&nbsp;сокет, такой способ выигрывает по&nbsp;скорости и&nbsp;эффективности расхода ресурсов.</p>
<p>Так что в&nbsp;следующий раз, когда Phoenix отрендерит страницу меньше чем за&nbsp;миллисекунду, подумайте о&nbsp;волшебном списке ввода-вывода, благодаря которому это становится возможным.</p>